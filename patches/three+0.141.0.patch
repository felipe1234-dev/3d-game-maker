diff --git a/node_modules/three/build/three.module.js b/node_modules/three/build/three.module.js
index c3f16a4..93cb79f 100644
--- a/node_modules/three/build/three.module.js
+++ b/node_modules/three/build/three.module.js
@@ -7587,8 +7587,7 @@ class Object3D extends EventDispatcher {
 
 		this.isObject3D = true;
 
-		Object.defineProperty( this, 'id', { value: _object3DId ++ } );
-
+		this.id = _object3DId++;
 		this.uuid = generateUUID();
 
 		this.name = '';
@@ -7623,22 +7622,26 @@ class Object3D extends EventDispatcher {
 			position: {
 				configurable: true,
 				enumerable: true,
-				value: position
+				value: position,
+				writable: true
 			},
 			rotation: {
 				configurable: true,
 				enumerable: true,
-				value: rotation
+				value: rotation,
+				writable: true
 			},
 			quaternion: {
 				configurable: true,
 				enumerable: true,
-				value: quaternion
+				value: quaternion,
+				writable: true
 			},
 			scale: {
 				configurable: true,
 				enumerable: true,
-				value: scale
+				value: scale,
+				writable: true
 			},
 			modelViewMatrix: {
 				value: new Matrix4()
diff --git a/node_modules/three/src/core/BufferAttribute.js b/node_modules/three/src/core/BufferAttribute.js
index e9a184b..ce61ceb 100644
--- a/node_modules/three/src/core/BufferAttribute.js
+++ b/node_modules/three/src/core/BufferAttribute.js
@@ -1,523 +1,403 @@
-import { Vector4 } from '../math/Vector4.js';
-import { Vector3 } from '../math/Vector3.js';
-import { Vector2 } from '../math/Vector2.js';
-import { Color } from '../math/Color.js';
-import { StaticDrawUsage } from '../constants.js';
+import { Vector4 } from "../math/Vector4.js";
+import { Vector3 } from "../math/Vector3.js";
+import { Vector2 } from "../math/Vector2.js";
+import { Color } from "../math/Color.js";
+import { StaticDrawUsage } from "../constants.js";
 
 const _vector = /*@__PURE__*/ new Vector3();
 const _vector2 = /*@__PURE__*/ new Vector2();
 
 class BufferAttribute {
+    constructor(array, itemSize, normalized) {
+        if (Array.isArray(array)) {
+            throw new TypeError(
+                "THREE.BufferAttribute: array should be a Typed Array."
+            );
+        }
 
-	constructor( array, itemSize, normalized ) {
+        this.isBufferAttribute = true;
 
-		if ( Array.isArray( array ) ) {
+        this.name = "";
 
-			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
+        this.array = array;
+        this.itemSize = itemSize;
+        this.count = array !== undefined ? array.length / itemSize : 0;
+        this.normalized = normalized === true;
 
-		}
+        this.usage = StaticDrawUsage;
+        this.updateRange = { offset: 0, count: -1 };
 
-		this.isBufferAttribute = true;
+        this.version = 0;
+    }
 
-		this.name = '';
+    onUploadCallback() {}
 
-		this.array = array;
-		this.itemSize = itemSize;
-		this.count = array !== undefined ? array.length / itemSize : 0;
-		this.normalized = normalized === true;
+    set needsUpdate(value) {
+        if (value === true) this.version++;
+    }
 
-		this.usage = StaticDrawUsage;
-		this.updateRange = { offset: 0, count: - 1 };
+    setUsage(value) {
+        this.usage = value;
 
-		this.version = 0;
+        return this;
+    }
 
-	}
+    copy(source) {
+        this.name = source.name;
+        this.array = new source.array.constructor(source.array);
+        this.itemSize = source.itemSize;
+        this.count = source.count;
+        this.normalized = source.normalized;
 
-	onUploadCallback() {}
+        this.usage = source.usage;
 
-	set needsUpdate( value ) {
+        return this;
+    }
 
-		if ( value === true ) this.version ++;
+    copyAt(index1, attribute, index2) {
+        index1 *= this.itemSize;
+        index2 *= attribute.itemSize;
+
+        for (let i = 0, l = this.itemSize; i < l; i++) {
+            this.array[index1 + i] = attribute.array[index2 + i];
+        }
+
+        return this;
+    }
+
+    copyArray(array) {
+        this.array.set(array);
+
+        return this;
+    }
+
+    copyColorsArray(colors) {
+        const array = this.array;
+        let offset = 0;
+
+        for (let i = 0, l = colors.length; i < l; i++) {
+            let color = colors[i];
+
+            if (color === undefined) {
+                console.warn(
+                    "THREE.BufferAttribute.copyColorsArray(): color is undefined",
+                    i
+                );
+                color = new Color();
+            }
+
+            array[offset++] = color.r;
+            array[offset++] = color.g;
+            array[offset++] = color.b;
+        }
+
+        return this;
+    }
+
+    copyVector2sArray(vectors) {
+        const array = this.array;
+        let offset = 0;
+
+        for (let i = 0, l = vectors.length; i < l; i++) {
+            let vector = vectors[i];
 
-	}
+            if (vector === undefined) {
+                console.warn(
+                    "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
+                    i
+                );
+                vector = new Vector2();
+            }
 
-	setUsage( value ) {
+            array[offset++] = vector.x;
+            array[offset++] = vector.y;
+        }
 
-		this.usage = value;
+        return this;
+    }
 
-		return this;
+    copyVector3sArray(vectors) {
+        const array = this.array;
+        let offset = 0;
 
-	}
+        for (let i = 0, l = vectors.length; i < l; i++) {
+            let vector = vectors[i];
 
-	copy( source ) {
+            if (vector === undefined) {
+                console.warn(
+                    "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
+                    i
+                );
+                vector = new Vector3();
+            }
 
-		this.name = source.name;
-		this.array = new source.array.constructor( source.array );
-		this.itemSize = source.itemSize;
-		this.count = source.count;
-		this.normalized = source.normalized;
+            array[offset++] = vector.x;
+            array[offset++] = vector.y;
+            array[offset++] = vector.z;
+        }
 
-		this.usage = source.usage;
+        return this;
+    }
 
-		return this;
+    copyVector4sArray(vectors) {
+        const array = this.array;
+        let offset = 0;
 
-	}
+        for (let i = 0, l = vectors.length; i < l; i++) {
+            let vector = vectors[i];
 
-	copyAt( index1, attribute, index2 ) {
+            if (vector === undefined) {
+                console.warn(
+                    "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
+                    i
+                );
+                vector = new Vector4();
+            }
 
-		index1 *= this.itemSize;
-		index2 *= attribute.itemSize;
+            array[offset++] = vector.x;
+            array[offset++] = vector.y;
+            array[offset++] = vector.z;
+            array[offset++] = vector.w;
+        }
 
-		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {
+        return this;
+    }
 
-			this.array[ index1 + i ] = attribute.array[ index2 + i ];
+    applyMatrix3(m) {
+        if (this.itemSize === 2) {
+            for (let i = 0, l = this.count; i < l; i++) {
+                _vector2.fromBufferAttribute(this, i);
+                _vector2.applyMatrix3(m);
 
-		}
+                this.setXY(i, _vector2.x, _vector2.y);
+            }
+        } else if (this.itemSize === 3) {
+            for (let i = 0, l = this.count; i < l; i++) {
+                _vector.fromBufferAttribute(this, i);
+                _vector.applyMatrix3(m);
 
-		return this;
+                this.setXYZ(i, _vector.x, _vector.y, _vector.z);
+            }
+        }
 
-	}
+        return this;
+    }
 
-	copyArray( array ) {
+    applyMatrix4(m) {
+        for (let i = 0, l = this.count; i < l; i++) {
+            _vector.fromBufferAttribute(this, i);
 
-		this.array.set( array );
+            _vector.applyMatrix4(m);
 
-		return this;
+            this.setXYZ(i, _vector.x, _vector.y, _vector.z);
+        }
 
-	}
+        return this;
+    }
 
-	copyColorsArray( colors ) {
+    applyNormalMatrix(m) {
+        for (let i = 0, l = this.count; i < l; i++) {
+            _vector.fromBufferAttribute(this, i);
 
-		const array = this.array;
-		let offset = 0;
+            _vector.applyNormalMatrix(m);
 
-		for ( let i = 0, l = colors.length; i < l; i ++ ) {
+            this.setXYZ(i, _vector.x, _vector.y, _vector.z);
+        }
 
-			let color = colors[ i ];
+        return this;
+    }
 
-			if ( color === undefined ) {
+    transformDirection(m) {
+        for (let i = 0, l = this.count; i < l; i++) {
+            _vector.fromBufferAttribute(this, i);
 
-				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
-				color = new Color();
+            _vector.transformDirection(m);
 
-			}
+            this.setXYZ(i, _vector.x, _vector.y, _vector.z);
+        }
 
-			array[ offset ++ ] = color.r;
-			array[ offset ++ ] = color.g;
-			array[ offset ++ ] = color.b;
+        return this;
+    }
 
-		}
+    set(value, offset = 0) {
+        this.array.set(value, offset);
 
-		return this;
+        return this;
+    }
 
-	}
+    getX(index) {
+        return this.array[index * this.itemSize];
+    }
 
-	copyVector2sArray( vectors ) {
+    setX(index, x) {
+        this.array[index * this.itemSize] = x;
 
-		const array = this.array;
-		let offset = 0;
+        return this;
+    }
 
-		for ( let i = 0, l = vectors.length; i < l; i ++ ) {
+    getY(index) {
+        return this.array[index * this.itemSize + 1];
+    }
 
-			let vector = vectors[ i ];
+    setY(index, y) {
+        this.array[index * this.itemSize + 1] = y;
 
-			if ( vector === undefined ) {
+        return this;
+    }
 
-				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
-				vector = new Vector2();
+    getZ(index) {
+        return this.array[index * this.itemSize + 2];
+    }
 
-			}
+    setZ(index, z) {
+        this.array[index * this.itemSize + 2] = z;
 
-			array[ offset ++ ] = vector.x;
-			array[ offset ++ ] = vector.y;
+        return this;
+    }
 
-		}
+    getW(index) {
+        return this.array[index * this.itemSize + 3];
+    }
 
-		return this;
+    setW(index, w) {
+        this.array[index * this.itemSize + 3] = w;
 
-	}
+        return this;
+    }
 
-	copyVector3sArray( vectors ) {
+    setXY(index, x, y) {
+        index *= this.itemSize;
 
-		const array = this.array;
-		let offset = 0;
+        this.array[index + 0] = x;
+        this.array[index + 1] = y;
 
-		for ( let i = 0, l = vectors.length; i < l; i ++ ) {
+        return this;
+    }
 
-			let vector = vectors[ i ];
+    setXYZ(index, x, y, z) {
+        index *= this.itemSize;
 
-			if ( vector === undefined ) {
+        this.array[index + 0] = x;
+        this.array[index + 1] = y;
+        this.array[index + 2] = z;
 
-				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
-				vector = new Vector3();
+        return this;
+    }
 
-			}
+    setXYZW(index, x, y, z, w) {
+        index *= this.itemSize;
 
-			array[ offset ++ ] = vector.x;
-			array[ offset ++ ] = vector.y;
-			array[ offset ++ ] = vector.z;
+        this.array[index + 0] = x;
+        this.array[index + 1] = y;
+        this.array[index + 2] = z;
+        this.array[index + 3] = w;
 
-		}
+        return this;
+    }
 
-		return this;
+    onUpload(callback) {
+        this.onUploadCallback = callback;
 
-	}
+        return this;
+    }
 
-	copyVector4sArray( vectors ) {
+    clone() {
+        return new this.constructor(this.array, this.itemSize).copy(this);
+    }
 
-		const array = this.array;
-		let offset = 0;
+    toJSON() {
+        const data = {
+            itemSize: this.itemSize,
+            type: this.array.constructor.name,
+            array: Array.prototype.slice.call(this.array),
+            normalized: this.normalized,
+        };
 
-		for ( let i = 0, l = vectors.length; i < l; i ++ ) {
-
-			let vector = vectors[ i ];
-
-			if ( vector === undefined ) {
-
-				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
-				vector = new Vector4();
-
-			}
-
-			array[ offset ++ ] = vector.x;
-			array[ offset ++ ] = vector.y;
-			array[ offset ++ ] = vector.z;
-			array[ offset ++ ] = vector.w;
-
-		}
-
-		return this;
-
-	}
-
-	applyMatrix3( m ) {
-
-		if ( this.itemSize === 2 ) {
-
-			for ( let i = 0, l = this.count; i < l; i ++ ) {
-
-				_vector2.fromBufferAttribute( this, i );
-				_vector2.applyMatrix3( m );
-
-				this.setXY( i, _vector2.x, _vector2.y );
-
-			}
-
-		} else if ( this.itemSize === 3 ) {
-
-			for ( let i = 0, l = this.count; i < l; i ++ ) {
-
-				_vector.fromBufferAttribute( this, i );
-				_vector.applyMatrix3( m );
-
-				this.setXYZ( i, _vector.x, _vector.y, _vector.z );
-
-			}
-
-		}
-
-		return this;
-
-	}
-
-	applyMatrix4( m ) {
-
-		for ( let i = 0, l = this.count; i < l; i ++ ) {
-
-			_vector.fromBufferAttribute( this, i );
-
-			_vector.applyMatrix4( m );
-
-			this.setXYZ( i, _vector.x, _vector.y, _vector.z );
-
-		}
-
-		return this;
-
-	}
-
-	applyNormalMatrix( m ) {
-
-		for ( let i = 0, l = this.count; i < l; i ++ ) {
-
-			_vector.fromBufferAttribute( this, i );
-
-			_vector.applyNormalMatrix( m );
-
-			this.setXYZ( i, _vector.x, _vector.y, _vector.z );
-
-		}
-
-		return this;
-
-	}
-
-	transformDirection( m ) {
-
-		for ( let i = 0, l = this.count; i < l; i ++ ) {
-
-			_vector.fromBufferAttribute( this, i );
-
-			_vector.transformDirection( m );
-
-			this.setXYZ( i, _vector.x, _vector.y, _vector.z );
-
-		}
-
-		return this;
-
-	}
-
-	set( value, offset = 0 ) {
-
-		this.array.set( value, offset );
-
-		return this;
-
-	}
-
-	getX( index ) {
-
-		return this.array[ index * this.itemSize ];
-
-	}
-
-	setX( index, x ) {
-
-		this.array[ index * this.itemSize ] = x;
-
-		return this;
-
-	}
-
-	getY( index ) {
-
-		return this.array[ index * this.itemSize + 1 ];
-
-	}
-
-	setY( index, y ) {
-
-		this.array[ index * this.itemSize + 1 ] = y;
-
-		return this;
-
-	}
-
-	getZ( index ) {
-
-		return this.array[ index * this.itemSize + 2 ];
-
-	}
-
-	setZ( index, z ) {
-
-		this.array[ index * this.itemSize + 2 ] = z;
-
-		return this;
-
-	}
-
-	getW( index ) {
-
-		return this.array[ index * this.itemSize + 3 ];
-
-	}
-
-	setW( index, w ) {
-
-		this.array[ index * this.itemSize + 3 ] = w;
-
-		return this;
-
-	}
-
-	setXY( index, x, y ) {
-
-		index *= this.itemSize;
-
-		this.array[ index + 0 ] = x;
-		this.array[ index + 1 ] = y;
-
-		return this;
-
-	}
-
-	setXYZ( index, x, y, z ) {
-
-		index *= this.itemSize;
-
-		this.array[ index + 0 ] = x;
-		this.array[ index + 1 ] = y;
-		this.array[ index + 2 ] = z;
-
-		return this;
-
-	}
-
-	setXYZW( index, x, y, z, w ) {
-
-		index *= this.itemSize;
-
-		this.array[ index + 0 ] = x;
-		this.array[ index + 1 ] = y;
-		this.array[ index + 2 ] = z;
-		this.array[ index + 3 ] = w;
-
-		return this;
-
-	}
-
-	onUpload( callback ) {
-
-		this.onUploadCallback = callback;
-
-		return this;
-
-	}
-
-	clone() {
-
-		return new this.constructor( this.array, this.itemSize ).copy( this );
-
-	}
-
-	toJSON() {
-
-		const data = {
-			itemSize: this.itemSize,
-			type: this.array.constructor.name,
-			array: Array.prototype.slice.call( this.array ),
-			normalized: this.normalized
-		};
-
-		if ( this.name !== '' ) data.name = this.name;
-		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
-		if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;
-
-		return data;
-
-	}
+        if (this.name !== "") data.name = this.name;
+        if (this.usage !== StaticDrawUsage) data.usage = this.usage;
+        if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
+            data.updateRange = this.updateRange;
 
+        return data;
+    }
 }
 
 //
 
 class Int8BufferAttribute extends BufferAttribute {
-
-	constructor( array, itemSize, normalized ) {
-
-		super( new Int8Array( array ), itemSize, normalized );
-
-	}
-
+    constructor(array, itemSize, normalized) {
+        super(new Int8Array(array), itemSize, normalized);
+    }
 }
 
 class Uint8BufferAttribute extends BufferAttribute {
-
-	constructor( array, itemSize, normalized ) {
-
-		super( new Uint8Array( array ), itemSize, normalized );
-
-	}
-
+    constructor(array, itemSize, normalized) {
+        super(new Uint8Array(array), itemSize, normalized);
+    }
 }
 
 class Uint8ClampedBufferAttribute extends BufferAttribute {
-
-	constructor( array, itemSize, normalized ) {
-
-		super( new Uint8ClampedArray( array ), itemSize, normalized );
-
-	}
-
+    constructor(array, itemSize, normalized) {
+        super(new Uint8ClampedArray(array), itemSize, normalized);
+    }
 }
 
 class Int16BufferAttribute extends BufferAttribute {
-
-	constructor( array, itemSize, normalized ) {
-
-		super( new Int16Array( array ), itemSize, normalized );
-
-	}
-
+    constructor(array, itemSize, normalized) {
+        super(new Int16Array(array), itemSize, normalized);
+    }
 }
 
 class Uint16BufferAttribute extends BufferAttribute {
-
-	constructor( array, itemSize, normalized ) {
-
-		super( new Uint16Array( array ), itemSize, normalized );
-
-	}
-
+    constructor(array, itemSize, normalized) {
+        super(new Uint16Array(array), itemSize, normalized);
+    }
 }
 
 class Int32BufferAttribute extends BufferAttribute {
-
-	constructor( array, itemSize, normalized ) {
-
-		super( new Int32Array( array ), itemSize, normalized );
-
-	}
-
+    constructor(array, itemSize, normalized) {
+        super(new Int32Array(array), itemSize, normalized);
+    }
 }
 
 class Uint32BufferAttribute extends BufferAttribute {
-
-	constructor( array, itemSize, normalized ) {
-
-		super( new Uint32Array( array ), itemSize, normalized );
-
-	}
-
+    constructor(array, itemSize, normalized) {
+        super(new Uint32Array(array), itemSize, normalized);
+    }
 }
 
 class Float16BufferAttribute extends BufferAttribute {
+    constructor(array, itemSize, normalized) {
+        super(new Uint16Array(array), itemSize, normalized);
 
-	constructor( array, itemSize, normalized ) {
-
-		super( new Uint16Array( array ), itemSize, normalized );
-
-		this.isFloat16BufferAttribute = true;
-
-	}
-
+        this.isFloat16BufferAttribute = true;
+    }
 }
 
-
 class Float32BufferAttribute extends BufferAttribute {
-
-	constructor( array, itemSize, normalized ) {
-
-		super( new Float32Array( array ), itemSize, normalized );
-
-	}
-
+    constructor(array, itemSize, normalized) {
+        super(new Float32Array(array), itemSize, normalized);
+    }
 }
 
 class Float64BufferAttribute extends BufferAttribute {
-
-	constructor( array, itemSize, normalized ) {
-
-		super( new Float64Array( array ), itemSize, normalized );
-
-	}
-
+    constructor(array, itemSize, normalized) {
+        super(new Float64Array(array), itemSize, normalized);
+    }
 }
 
 //
 
 export {
-	Float64BufferAttribute,
-	Float32BufferAttribute,
-	Float16BufferAttribute,
-	Uint32BufferAttribute,
-	Int32BufferAttribute,
-	Uint16BufferAttribute,
-	Int16BufferAttribute,
-	Uint8ClampedBufferAttribute,
-	Uint8BufferAttribute,
-	Int8BufferAttribute,
-	BufferAttribute
+    Float64BufferAttribute,
+    Float32BufferAttribute,
+    Float16BufferAttribute,
+    Uint32BufferAttribute,
+    Int32BufferAttribute,
+    Uint16BufferAttribute,
+    Int16BufferAttribute,
+    Uint8ClampedBufferAttribute,
+    Uint8BufferAttribute,
+    Int8BufferAttribute,
+    BufferAttribute,
 };
diff --git a/node_modules/three/src/core/BufferGeometry.js b/node_modules/three/src/core/BufferGeometry.js
index 68bf016..424d1ac 100644
--- a/node_modules/three/src/core/BufferGeometry.js
+++ b/node_modules/three/src/core/BufferGeometry.js
@@ -1,14 +1,19 @@
-import { Vector3 } from '../math/Vector3.js';
-import { Vector2 } from '../math/Vector2.js';
-import { Box3 } from '../math/Box3.js';
-import { EventDispatcher } from './EventDispatcher.js';
-import { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';
-import { Sphere } from '../math/Sphere.js';
-import { Object3D } from './Object3D.js';
-import { Matrix4 } from '../math/Matrix4.js';
-import { Matrix3 } from '../math/Matrix3.js';
-import * as MathUtils from '../math/MathUtils.js';
-import { arrayNeedsUint32 } from '../utils.js';
+import { Vector3 } from "../math/Vector3.js";
+import { Vector2 } from "../math/Vector2.js";
+import { Box3 } from "../math/Box3.js";
+import { EventDispatcher } from "./EventDispatcher.js";
+import {
+    BufferAttribute,
+    Float32BufferAttribute,
+    Uint16BufferAttribute,
+    Uint32BufferAttribute,
+} from "./BufferAttribute.js";
+import { Sphere } from "../math/Sphere.js";
+import { Object3D } from "./Object3D.js";
+import { Matrix4 } from "../math/Matrix4.js";
+import { Matrix3 } from "../math/Matrix3.js";
+import * as MathUtils from "../math/MathUtils.js";
+import { arrayNeedsUint32 } from "../utils.js";
 
 let _id = 0;
 
@@ -20,1111 +25,953 @@ const _boxMorphTargets = /*@__PURE__*/ new Box3();
 const _vector = /*@__PURE__*/ new Vector3();
 
 class BufferGeometry extends EventDispatcher {
+    constructor() {
+        super();
 
-	constructor() {
+        this.isBufferGeometry = true;
 
-		super();
+        Object.defineProperty(this, "id", { value: _id++ });
 
-		this.isBufferGeometry = true;
+        this.uuid = MathUtils.generateUUID();
 
-		Object.defineProperty( this, 'id', { value: _id ++ } );
+        this.name = "";
+        this.type = "BufferGeometry";
 
-		this.uuid = MathUtils.generateUUID();
+        this.index = null;
+        this.attributes = {};
 
-		this.name = '';
-		this.type = 'BufferGeometry';
+        this.morphAttributes = {};
+        this.morphTargetsRelative = false;
 
-		this.index = null;
-		this.attributes = {};
+        this.groups = [];
 
-		this.morphAttributes = {};
-		this.morphTargetsRelative = false;
+        this.boundingBox = null;
+        this.boundingSphere = null;
 
-		this.groups = [];
+        this.drawRange = { start: 0, count: Infinity };
 
-		this.boundingBox = null;
-		this.boundingSphere = null;
+        this.userData = {};
+    }
 
-		this.drawRange = { start: 0, count: Infinity };
+    getIndex() {
+        return this.index;
+    }
 
-		this.userData = {};
+    setIndex(index) {
+        if (Array.isArray(index)) {
+            this.index = new (
+                arrayNeedsUint32(index)
+                    ? Uint32BufferAttribute
+                    : Uint16BufferAttribute
+            )(index, 1);
+        } else {
+            this.index = index;
+        }
 
-	}
+        return this;
+    }
 
-	getIndex() {
+    getAttribute(name) {
+        return this.attributes[name];
+    }
 
-		return this.index;
+    setAttribute(name, attribute) {
+        this.attributes[name] = attribute;
 
-	}
+        return this;
+    }
 
-	setIndex( index ) {
+    deleteAttribute(name) {
+        delete this.attributes[name];
 
-		if ( Array.isArray( index ) ) {
+        return this;
+    }
 
-			this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );
+    hasAttribute(name) {
+        return this.attributes[name] !== undefined;
+    }
 
-		} else {
+    addGroup(start, count, materialIndex = 0) {
+        this.groups.push({
+            start: start,
+            count: count,
+            materialIndex: materialIndex,
+        });
+    }
 
-			this.index = index;
+    clearGroups() {
+        this.groups = [];
+    }
 
-		}
+    setDrawRange(start, count) {
+        this.drawRange.start = start;
+        this.drawRange.count = count;
+    }
 
-		return this;
+    applyMatrix4(matrix) {
+        const position = this.attributes.position;
 
-	}
+        if (position !== undefined) {
+            position.applyMatrix4(matrix);
 
-	getAttribute( name ) {
+            position.needsUpdate = true;
+        }
 
-		return this.attributes[ name ];
+        const normal = this.attributes.normal;
 
-	}
+        if (normal !== undefined) {
+            const normalMatrix = new Matrix3().getNormalMatrix(matrix);
 
-	setAttribute( name, attribute ) {
+            normal.applyNormalMatrix(normalMatrix);
 
-		this.attributes[ name ] = attribute;
+            normal.needsUpdate = true;
+        }
 
-		return this;
+        const tangent = this.attributes.tangent;
 
-	}
+        if (tangent !== undefined) {
+            tangent.transformDirection(matrix);
 
-	deleteAttribute( name ) {
+            tangent.needsUpdate = true;
+        }
 
-		delete this.attributes[ name ];
+        if (this.boundingBox !== null) {
+            this.computeBoundingBox();
+        }
 
-		return this;
+        if (this.boundingSphere !== null) {
+            this.computeBoundingSphere();
+        }
 
-	}
+        return this;
+    }
 
-	hasAttribute( name ) {
+    applyQuaternion(q) {
+        _m1.makeRotationFromQuaternion(q);
 
-		return this.attributes[ name ] !== undefined;
+        this.applyMatrix4(_m1);
 
-	}
+        return this;
+    }
 
-	addGroup( start, count, materialIndex = 0 ) {
+    rotateX(angle) {
+        // rotate geometry around world x-axis
 
-		this.groups.push( {
+        _m1.makeRotationX(angle);
 
-			start: start,
-			count: count,
-			materialIndex: materialIndex
+        this.applyMatrix4(_m1);
 
-		} );
+        return this;
+    }
 
-	}
+    rotateY(angle) {
+        // rotate geometry around world y-axis
 
-	clearGroups() {
+        _m1.makeRotationY(angle);
 
-		this.groups = [];
+        this.applyMatrix4(_m1);
 
-	}
+        return this;
+    }
 
-	setDrawRange( start, count ) {
+    rotateZ(angle) {
+        // rotate geometry around world z-axis
 
-		this.drawRange.start = start;
-		this.drawRange.count = count;
+        _m1.makeRotationZ(angle);
 
-	}
+        this.applyMatrix4(_m1);
 
-	applyMatrix4( matrix ) {
+        return this;
+    }
 
-		const position = this.attributes.position;
+    translate(x, y, z) {
+        // translate geometry
 
-		if ( position !== undefined ) {
+        _m1.makeTranslation(x, y, z);
 
-			position.applyMatrix4( matrix );
+        this.applyMatrix4(_m1);
 
-			position.needsUpdate = true;
+        return this;
+    }
 
-		}
+    scale(x, y, z) {
+        // scale geometry
 
-		const normal = this.attributes.normal;
+        _m1.makeScale(x, y, z);
 
-		if ( normal !== undefined ) {
+        this.applyMatrix4(_m1);
 
-			const normalMatrix = new Matrix3().getNormalMatrix( matrix );
+        return this;
+    }
 
-			normal.applyNormalMatrix( normalMatrix );
+    lookAt(vector) {
+        _obj.lookAt(vector);
 
-			normal.needsUpdate = true;
+        _obj.updateMatrix();
 
-		}
+        this.applyMatrix4(_obj.matrix);
 
-		const tangent = this.attributes.tangent;
+        return this;
+    }
 
-		if ( tangent !== undefined ) {
+    center() {
+        this.computeBoundingBox();
 
-			tangent.transformDirection( matrix );
+        this.boundingBox.getCenter(_offset).negate();
 
-			tangent.needsUpdate = true;
+        this.translate(_offset.x, _offset.y, _offset.z);
 
-		}
+        return this;
+    }
 
-		if ( this.boundingBox !== null ) {
+    setFromPoints(points) {
+        const position = [];
 
-			this.computeBoundingBox();
+        for (let i = 0, l = points.length; i < l; i++) {
+            const point = points[i];
+            position.push(point.x, point.y, point.z || 0);
+        }
 
-		}
+        this.setAttribute("position", new Float32BufferAttribute(position, 3));
 
-		if ( this.boundingSphere !== null ) {
+        return this;
+    }
 
-			this.computeBoundingSphere();
+    computeBoundingBox() {
+        if (this.boundingBox === null) {
+            this.boundingBox = new Box3();
+        }
 
-		}
+        const position = this.attributes.position;
+        const morphAttributesPosition = this.morphAttributes.position;
 
-		return this;
+        if (position && position.isGLBufferAttribute) {
+            console.error(
+                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
+                this
+            );
 
-	}
+            this.boundingBox.set(
+                new Vector3(-Infinity, -Infinity, -Infinity),
+                new Vector3(+Infinity, +Infinity, +Infinity)
+            );
 
-	applyQuaternion( q ) {
+            return;
+        }
 
-		_m1.makeRotationFromQuaternion( q );
+        if (position !== undefined) {
+            this.boundingBox.setFromBufferAttribute(position);
 
-		this.applyMatrix4( _m1 );
+            // process morph attributes if present
 
-		return this;
+            if (morphAttributesPosition) {
+                for (
+                    let i = 0, il = morphAttributesPosition.length;
+                    i < il;
+                    i++
+                ) {
+                    const morphAttribute = morphAttributesPosition[i];
+                    _box.setFromBufferAttribute(morphAttribute);
 
-	}
+                    if (this.morphTargetsRelative) {
+                        _vector.addVectors(this.boundingBox.min, _box.min);
+                        this.boundingBox.expandByPoint(_vector);
 
-	rotateX( angle ) {
+                        _vector.addVectors(this.boundingBox.max, _box.max);
+                        this.boundingBox.expandByPoint(_vector);
+                    } else {
+                        this.boundingBox.expandByPoint(_box.min);
+                        this.boundingBox.expandByPoint(_box.max);
+                    }
+                }
+            }
+        } else {
+            this.boundingBox.makeEmpty();
+        }
 
-		// rotate geometry around world x-axis
+        if (
+            isNaN(this.boundingBox.min.x) ||
+            isNaN(this.boundingBox.min.y) ||
+            isNaN(this.boundingBox.min.z)
+        ) {
+            console.error(
+                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
+                this
+            );
+        }
+    }
+
+    computeBoundingSphere() {
+        if (this.boundingSphere === null) {
+            this.boundingSphere = new Sphere();
+        }
+
+        const position = this.attributes.position;
+        const morphAttributesPosition = this.morphAttributes.position;
+
+        if (position && position.isGLBufferAttribute) {
+            console.error(
+                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
+                this
+            );
+
+            this.boundingSphere.set(new Vector3(), Infinity);
+
+            return;
+        }
+
+        if (position) {
+            // first, find the center of the bounding sphere
+
+            const center = this.boundingSphere.center;
+
+            _box.setFromBufferAttribute(position);
+
+            // process morph attributes if present
+
+            if (morphAttributesPosition) {
+                for (
+                    let i = 0, il = morphAttributesPosition.length;
+                    i < il;
+                    i++
+                ) {
+                    const morphAttribute = morphAttributesPosition[i];
+                    _boxMorphTargets.setFromBufferAttribute(morphAttribute);
+
+                    if (this.morphTargetsRelative) {
+                        _vector.addVectors(_box.min, _boxMorphTargets.min);
+                        _box.expandByPoint(_vector);
+
+                        _vector.addVectors(_box.max, _boxMorphTargets.max);
+                        _box.expandByPoint(_vector);
+                    } else {
+                        _box.expandByPoint(_boxMorphTargets.min);
+                        _box.expandByPoint(_boxMorphTargets.max);
+                    }
+                }
+            }
+
+            _box.getCenter(center);
+
+            // second, try to find a boundingSphere with a radius smaller than the
+            // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
+
+            let maxRadiusSq = 0;
+
+            for (let i = 0, il = position.count; i < il; i++) {
+                _vector.fromBufferAttribute(position, i);
+
+                maxRadiusSq = Math.max(
+                    maxRadiusSq,
+                    center.distanceToSquared(_vector)
+                );
+            }
+
+            // process morph attributes if present
+
+            if (morphAttributesPosition) {
+                for (
+                    let i = 0, il = morphAttributesPosition.length;
+                    i < il;
+                    i++
+                ) {
+                    const morphAttribute = morphAttributesPosition[i];
+                    const morphTargetsRelative = this.morphTargetsRelative;
+
+                    for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
+                        _vector.fromBufferAttribute(morphAttribute, j);
+
+                        if (morphTargetsRelative) {
+                            _offset.fromBufferAttribute(position, j);
+                            _vector.add(_offset);
+                        }
+
+                        maxRadiusSq = Math.max(
+                            maxRadiusSq,
+                            center.distanceToSquared(_vector)
+                        );
+                    }
+                }
+            }
+
+            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
+
+            if (isNaN(this.boundingSphere.radius)) {
+                console.error(
+                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
+                    this
+                );
+            }
+        }
+    }
+
+    computeTangents() {
+        const index = this.index;
+        const attributes = this.attributes;
+
+        // based on http://www.terathon.com/code/tangent.html
+        // (per vertex tangents)
+
+        if (
+            index === null ||
+            attributes.position === undefined ||
+            attributes.normal === undefined ||
+            attributes.uv === undefined
+        ) {
+            console.error(
+                "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
+            );
+            return;
+        }
+
+        const indices = index.array;
+        const positions = attributes.position.array;
+        const normals = attributes.normal.array;
+        const uvs = attributes.uv.array;
+
+        const nVertices = positions.length / 3;
+
+        if (this.hasAttribute("tangent") === false) {
+            this.setAttribute(
+                "tangent",
+                new BufferAttribute(new Float32Array(4 * nVertices), 4)
+            );
+        }
+
+        const tangents = this.getAttribute("tangent").array;
+
+        const tan1 = [],
+            tan2 = [];
+
+        for (let i = 0; i < nVertices; i++) {
+            tan1[i] = new Vector3();
+            tan2[i] = new Vector3();
+        }
+
+        const vA = new Vector3(),
+            vB = new Vector3(),
+            vC = new Vector3(),
+            uvA = new Vector2(),
+            uvB = new Vector2(),
+            uvC = new Vector2(),
+            sdir = new Vector3(),
+            tdir = new Vector3();
+
+        function handleTriangle(a, b, c) {
+            vA.fromArray(positions, a * 3);
+            vB.fromArray(positions, b * 3);
+            vC.fromArray(positions, c * 3);
+
+            uvA.fromArray(uvs, a * 2);
+            uvB.fromArray(uvs, b * 2);
+            uvC.fromArray(uvs, c * 2);
+
+            vB.sub(vA);
+            vC.sub(vA);
+
+            uvB.sub(uvA);
+            uvC.sub(uvA);
+
+            const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);
+
+            // silently ignore degenerate uv triangles having coincident or colinear vertices
+
+            if (!isFinite(r)) return;
+
+            sdir.copy(vB)
+                .multiplyScalar(uvC.y)
+                .addScaledVector(vC, -uvB.y)
+                .multiplyScalar(r);
+            tdir.copy(vC)
+                .multiplyScalar(uvB.x)
+                .addScaledVector(vB, -uvC.x)
+                .multiplyScalar(r);
+
+            tan1[a].add(sdir);
+            tan1[b].add(sdir);
+            tan1[c].add(sdir);
+
+            tan2[a].add(tdir);
+            tan2[b].add(tdir);
+            tan2[c].add(tdir);
+        }
+
+        let groups = this.groups;
+
+        if (groups.length === 0) {
+            groups = [
+                {
+                    start: 0,
+                    count: indices.length,
+                },
+            ];
+        }
+
+        for (let i = 0, il = groups.length; i < il; ++i) {
+            const group = groups[i];
+
+            const start = group.start;
+            const count = group.count;
+
+            for (let j = start, jl = start + count; j < jl; j += 3) {
+                handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
+            }
+        }
+
+        const tmp = new Vector3(),
+            tmp2 = new Vector3();
+        const n = new Vector3(),
+            n2 = new Vector3();
+
+        function handleVertex(v) {
+            n.fromArray(normals, v * 3);
+            n2.copy(n);
+
+            const t = tan1[v];
+
+            // Gram-Schmidt orthogonalize
+
+            tmp.copy(t);
+            tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
+
+            // Calculate handedness
+
+            tmp2.crossVectors(n2, t);
+            const test = tmp2.dot(tan2[v]);
+            const w = test < 0.0 ? -1.0 : 1.0;
+
+            tangents[v * 4] = tmp.x;
+            tangents[v * 4 + 1] = tmp.y;
+            tangents[v * 4 + 2] = tmp.z;
+            tangents[v * 4 + 3] = w;
+        }
+
+        for (let i = 0, il = groups.length; i < il; ++i) {
+            const group = groups[i];
+
+            const start = group.start;
+            const count = group.count;
+
+            for (let j = start, jl = start + count; j < jl; j += 3) {
+                handleVertex(indices[j + 0]);
+                handleVertex(indices[j + 1]);
+                handleVertex(indices[j + 2]);
+            }
+        }
+    }
+
+    computeVertexNormals() {
+        const index = this.index;
+        const positionAttribute = this.getAttribute("position");
+
+        if (positionAttribute !== undefined) {
+            let normalAttribute = this.getAttribute("normal");
+
+            if (normalAttribute === undefined) {
+                normalAttribute = new BufferAttribute(
+                    new Float32Array(positionAttribute.count * 3),
+                    3
+                );
+                this.setAttribute("normal", normalAttribute);
+            } else {
+                // reset existing normals to zero
+
+                for (let i = 0, il = normalAttribute.count; i < il; i++) {
+                    normalAttribute.setXYZ(i, 0, 0, 0);
+                }
+            }
+
+            const pA = new Vector3(),
+                pB = new Vector3(),
+                pC = new Vector3();
+            const nA = new Vector3(),
+                nB = new Vector3(),
+                nC = new Vector3();
+            const cb = new Vector3(),
+                ab = new Vector3();
+
+            // indexed elements
+
+            if (index) {
+                for (let i = 0, il = index.count; i < il; i += 3) {
+                    const vA = index.getX(i + 0);
+                    const vB = index.getX(i + 1);
+                    const vC = index.getX(i + 2);
+
+                    pA.fromBufferAttribute(positionAttribute, vA);
+                    pB.fromBufferAttribute(positionAttribute, vB);
+                    pC.fromBufferAttribute(positionAttribute, vC);
+
+                    cb.subVectors(pC, pB);
+                    ab.subVectors(pA, pB);
+                    cb.cross(ab);
+
+                    nA.fromBufferAttribute(normalAttribute, vA);
+                    nB.fromBufferAttribute(normalAttribute, vB);
+                    nC.fromBufferAttribute(normalAttribute, vC);
+
+                    nA.add(cb);
+                    nB.add(cb);
+                    nC.add(cb);
+
+                    normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
+                    normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
+                    normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
+                }
+            } else {
+                // non-indexed elements (unconnected triangle soup)
+
+                for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
+                    pA.fromBufferAttribute(positionAttribute, i + 0);
+                    pB.fromBufferAttribute(positionAttribute, i + 1);
+                    pC.fromBufferAttribute(positionAttribute, i + 2);
+
+                    cb.subVectors(pC, pB);
+                    ab.subVectors(pA, pB);
+                    cb.cross(ab);
+
+                    normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
+                    normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
+                    normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
+                }
+            }
+
+            this.normalizeNormals();
+
+            normalAttribute.needsUpdate = true;
+        }
+    }
+
+    merge(geometry, offset) {
+        if (!(geometry && geometry.isBufferGeometry)) {
+            console.error(
+                "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
+                geometry
+            );
+            return;
+        }
+
+        if (offset === undefined) {
+            offset = 0;
+
+            console.warn(
+                "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. " +
+                    "Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
+            );
+        }
 
-		_m1.makeRotationX( angle );
+        const attributes = this.attributes;
 
-		this.applyMatrix4( _m1 );
+        for (const key in attributes) {
+            if (geometry.attributes[key] === undefined) continue;
 
-		return this;
+            const attribute1 = attributes[key];
+            const attributeArray1 = attribute1.array;
 
-	}
+            const attribute2 = geometry.attributes[key];
+            const attributeArray2 = attribute2.array;
 
-	rotateY( angle ) {
+            const attributeOffset = attribute2.itemSize * offset;
+            const length = Math.min(
+                attributeArray2.length,
+                attributeArray1.length - attributeOffset
+            );
 
-		// rotate geometry around world y-axis
+            for (let i = 0, j = attributeOffset; i < length; i++, j++) {
+                attributeArray1[j] = attributeArray2[i];
+            }
+        }
 
-		_m1.makeRotationY( angle );
+        return this;
+    }
 
-		this.applyMatrix4( _m1 );
+    normalizeNormals() {
+        const normals = this.attributes.normal;
 
-		return this;
+        for (let i = 0, il = normals.count; i < il; i++) {
+            _vector.fromBufferAttribute(normals, i);
 
-	}
+            _vector.normalize();
 
-	rotateZ( angle ) {
+            normals.setXYZ(i, _vector.x, _vector.y, _vector.z);
+        }
+    }
 
-		// rotate geometry around world z-axis
+    toNonIndexed() {
+        function convertBufferAttribute(attribute, indices) {
+            const array = attribute.array;
+            const itemSize = attribute.itemSize;
+            const normalized = attribute.normalized;
 
-		_m1.makeRotationZ( angle );
+            const array2 = new array.constructor(indices.length * itemSize);
 
-		this.applyMatrix4( _m1 );
+            let index = 0,
+                index2 = 0;
 
-		return this;
+            for (let i = 0, l = indices.length; i < l; i++) {
+                if (attribute.isInterleavedBufferAttribute) {
+                    index =
+                        indices[i] * attribute.data.stride + attribute.offset;
+                } else {
+                    index = indices[i] * itemSize;
+                }
 
-	}
+                for (let j = 0; j < itemSize; j++) {
+                    array2[index2++] = array[index++];
+                }
+            }
 
-	translate( x, y, z ) {
+            return new BufferAttribute(array2, itemSize, normalized);
+        }
 
-		// translate geometry
+        //
 
-		_m1.makeTranslation( x, y, z );
+        if (this.index === null) {
+            console.warn(
+                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
+            );
+            return this;
+        }
 
-		this.applyMatrix4( _m1 );
+        const geometry2 = new BufferGeometry();
 
-		return this;
+        const indices = this.index.array;
+        const attributes = this.attributes;
 
-	}
+        // attributes
 
-	scale( x, y, z ) {
+        for (const name in attributes) {
+            const attribute = attributes[name];
 
-		// scale geometry
+            const newAttribute = convertBufferAttribute(attribute, indices);
 
-		_m1.makeScale( x, y, z );
+            geometry2.setAttribute(name, newAttribute);
+        }
 
-		this.applyMatrix4( _m1 );
+        // morph attributes
 
-		return this;
+        const morphAttributes = this.morphAttributes;
 
-	}
+        for (const name in morphAttributes) {
+            const morphArray = [];
+            const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes
 
-	lookAt( vector ) {
+            for (let i = 0, il = morphAttribute.length; i < il; i++) {
+                const attribute = morphAttribute[i];
 
-		_obj.lookAt( vector );
+                const newAttribute = convertBufferAttribute(attribute, indices);
 
-		_obj.updateMatrix();
+                morphArray.push(newAttribute);
+            }
 
-		this.applyMatrix4( _obj.matrix );
+            geometry2.morphAttributes[name] = morphArray;
+        }
 
-		return this;
+        geometry2.morphTargetsRelative = this.morphTargetsRelative;
 
-	}
+        // groups
 
-	center() {
+        const groups = this.groups;
 
-		this.computeBoundingBox();
+        for (let i = 0, l = groups.length; i < l; i++) {
+            const group = groups[i];
+            geometry2.addGroup(group.start, group.count, group.materialIndex);
+        }
 
-		this.boundingBox.getCenter( _offset ).negate();
+        return geometry2;
+    }
 
-		this.translate( _offset.x, _offset.y, _offset.z );
+    toJSON() {
+        const data = {
+            metadata: {
+                version: 4.5,
+                type: "BufferGeometry",
+                generator: "BufferGeometry.toJSON",
+            },
+        };
 
-		return this;
+        // standard BufferGeometry serialization
 
-	}
+        data.uuid = this.uuid;
+        data.type = this.type;
+        if (this.name !== "") data.name = this.name;
+        if (Object.keys(this.userData).length > 0)
+            data.userData = this.userData;
 
-	setFromPoints( points ) {
+        if (this.parameters !== undefined) {
+            const parameters = this.parameters;
 
-		const position = [];
+            for (const key in parameters) {
+                if (parameters[key] !== undefined) data[key] = parameters[key];
+            }
+        }
 
-		for ( let i = 0, l = points.length; i < l; i ++ ) {
+        // for simplicity the code assumes attributes are not shared across geometries, see #15811
 
-			const point = points[ i ];
-			position.push( point.x, point.y, point.z || 0 );
+        data.data = { attributes: {} };
 
-		}
+        const index = this.index;
 
-		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );
+        if (index !== null) {
+            data.data.index = {
+                type: index.array.constructor.name,
+                array: Array.prototype.slice.call(index.array),
+            };
+        }
 
-		return this;
+        const attributes = this.attributes;
 
-	}
+        for (const key in attributes) {
+            const attribute = attributes[key];
 
-	computeBoundingBox() {
+            data.data.attributes[key] = attribute.toJSON(data.data);
+        }
 
-		if ( this.boundingBox === null ) {
+        const morphAttributes = {};
+        let hasMorphAttributes = false;
 
-			this.boundingBox = new Box3();
+        for (const key in this.morphAttributes) {
+            const attributeArray = this.morphAttributes[key];
 
-		}
+            const array = [];
 
-		const position = this.attributes.position;
-		const morphAttributesPosition = this.morphAttributes.position;
+            for (let i = 0, il = attributeArray.length; i < il; i++) {
+                const attribute = attributeArray[i];
 
-		if ( position && position.isGLBufferAttribute ) {
+                array.push(attribute.toJSON(data.data));
+            }
 
-			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );
+            if (array.length > 0) {
+                morphAttributes[key] = array;
 
-			this.boundingBox.set(
-				new Vector3( - Infinity, - Infinity, - Infinity ),
-				new Vector3( + Infinity, + Infinity, + Infinity )
-			);
+                hasMorphAttributes = true;
+            }
+        }
 
-			return;
+        if (hasMorphAttributes) {
+            data.data.morphAttributes = morphAttributes;
+            data.data.morphTargetsRelative = this.morphTargetsRelative;
+        }
 
-		}
+        const groups = this.groups;
 
-		if ( position !== undefined ) {
+        if (groups.length > 0) {
+            data.data.groups = JSON.parse(JSON.stringify(groups));
+        }
 
-			this.boundingBox.setFromBufferAttribute( position );
+        const boundingSphere = this.boundingSphere;
 
-			// process morph attributes if present
+        if (boundingSphere !== null) {
+            data.data.boundingSphere = {
+                center: boundingSphere.center.toArray(),
+                radius: boundingSphere.radius,
+            };
+        }
 
-			if ( morphAttributesPosition ) {
+        return data;
+    }
 
-				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {
+    clone() {
+        return new this.constructor().copy(this);
+    }
 
-					const morphAttribute = morphAttributesPosition[ i ];
-					_box.setFromBufferAttribute( morphAttribute );
+    copy(source) {
+        // reset
 
-					if ( this.morphTargetsRelative ) {
+        this.index = null;
+        this.attributes = {};
+        this.morphAttributes = {};
+        this.groups = [];
+        this.boundingBox = null;
+        this.boundingSphere = null;
 
-						_vector.addVectors( this.boundingBox.min, _box.min );
-						this.boundingBox.expandByPoint( _vector );
+        // used for storing cloned, shared data
 
-						_vector.addVectors( this.boundingBox.max, _box.max );
-						this.boundingBox.expandByPoint( _vector );
+        const data = {};
 
-					} else {
+        // name
 
-						this.boundingBox.expandByPoint( _box.min );
-						this.boundingBox.expandByPoint( _box.max );
+        this.name = source.name;
 
-					}
+        // index
 
-				}
+        const index = source.index;
 
-			}
+        if (index !== null) {
+            this.setIndex(index.clone(data));
+        }
 
-		} else {
+        // attributes
 
-			this.boundingBox.makeEmpty();
+        const attributes = source.attributes;
 
-		}
+        for (const name in attributes) {
+            const attribute = attributes[name];
+            this.setAttribute(name, attribute.clone(data));
+        }
 
-		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
+        // morph attributes
 
-			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );
+        const morphAttributes = source.morphAttributes;
 
-		}
+        for (const name in morphAttributes) {
+            const array = [];
+            const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes
 
-	}
+            for (let i = 0, l = morphAttribute.length; i < l; i++) {
+                array.push(morphAttribute[i].clone(data));
+            }
 
-	computeBoundingSphere() {
+            this.morphAttributes[name] = array;
+        }
 
-		if ( this.boundingSphere === null ) {
+        this.morphTargetsRelative = source.morphTargetsRelative;
 
-			this.boundingSphere = new Sphere();
+        // groups
 
-		}
+        const groups = source.groups;
 
-		const position = this.attributes.position;
-		const morphAttributesPosition = this.morphAttributes.position;
+        for (let i = 0, l = groups.length; i < l; i++) {
+            const group = groups[i];
+            this.addGroup(group.start, group.count, group.materialIndex);
+        }
 
-		if ( position && position.isGLBufferAttribute ) {
+        // bounding box
 
-			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );
+        const boundingBox = source.boundingBox;
 
-			this.boundingSphere.set( new Vector3(), Infinity );
+        if (boundingBox !== null) {
+            this.boundingBox = boundingBox.clone();
+        }
 
-			return;
+        // bounding sphere
 
-		}
+        const boundingSphere = source.boundingSphere;
 
-		if ( position ) {
+        if (boundingSphere !== null) {
+            this.boundingSphere = boundingSphere.clone();
+        }
 
-			// first, find the center of the bounding sphere
+        // draw range
 
-			const center = this.boundingSphere.center;
+        this.drawRange.start = source.drawRange.start;
+        this.drawRange.count = source.drawRange.count;
 
-			_box.setFromBufferAttribute( position );
+        // user data
 
-			// process morph attributes if present
+        this.userData = source.userData;
 
-			if ( morphAttributesPosition ) {
+        // geometry generator parameters
 
-				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {
+        if (source.parameters !== undefined)
+            this.parameters = Object.assign({}, source.parameters);
 
-					const morphAttribute = morphAttributesPosition[ i ];
-					_boxMorphTargets.setFromBufferAttribute( morphAttribute );
-
-					if ( this.morphTargetsRelative ) {
-
-						_vector.addVectors( _box.min, _boxMorphTargets.min );
-						_box.expandByPoint( _vector );
-
-						_vector.addVectors( _box.max, _boxMorphTargets.max );
-						_box.expandByPoint( _vector );
-
-					} else {
-
-						_box.expandByPoint( _boxMorphTargets.min );
-						_box.expandByPoint( _boxMorphTargets.max );
-
-					}
-
-				}
-
-			}
-
-			_box.getCenter( center );
-
-			// second, try to find a boundingSphere with a radius smaller than the
-			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
-
-			let maxRadiusSq = 0;
-
-			for ( let i = 0, il = position.count; i < il; i ++ ) {
-
-				_vector.fromBufferAttribute( position, i );
-
-				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );
-
-			}
-
-			// process morph attributes if present
-
-			if ( morphAttributesPosition ) {
-
-				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {
-
-					const morphAttribute = morphAttributesPosition[ i ];
-					const morphTargetsRelative = this.morphTargetsRelative;
-
-					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {
-
-						_vector.fromBufferAttribute( morphAttribute, j );
-
-						if ( morphTargetsRelative ) {
-
-							_offset.fromBufferAttribute( position, j );
-							_vector.add( _offset );
-
-						}
-
-						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );
-
-					}
-
-				}
-
-			}
-
-			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
-
-			if ( isNaN( this.boundingSphere.radius ) ) {
-
-				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );
-
-			}
-
-		}
-
-	}
-
-	computeTangents() {
-
-		const index = this.index;
-		const attributes = this.attributes;
-
-		// based on http://www.terathon.com/code/tangent.html
-		// (per vertex tangents)
-
-		if ( index === null ||
-			 attributes.position === undefined ||
-			 attributes.normal === undefined ||
-			 attributes.uv === undefined ) {
-
-			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
-			return;
-
-		}
-
-		const indices = index.array;
-		const positions = attributes.position.array;
-		const normals = attributes.normal.array;
-		const uvs = attributes.uv.array;
-
-		const nVertices = positions.length / 3;
-
-		if ( this.hasAttribute( 'tangent' ) === false ) {
-
-			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );
-
-		}
-
-		const tangents = this.getAttribute( 'tangent' ).array;
-
-		const tan1 = [], tan2 = [];
-
-		for ( let i = 0; i < nVertices; i ++ ) {
-
-			tan1[ i ] = new Vector3();
-			tan2[ i ] = new Vector3();
-
-		}
-
-		const vA = new Vector3(),
-			vB = new Vector3(),
-			vC = new Vector3(),
-
-			uvA = new Vector2(),
-			uvB = new Vector2(),
-			uvC = new Vector2(),
-
-			sdir = new Vector3(),
-			tdir = new Vector3();
-
-		function handleTriangle( a, b, c ) {
-
-			vA.fromArray( positions, a * 3 );
-			vB.fromArray( positions, b * 3 );
-			vC.fromArray( positions, c * 3 );
-
-			uvA.fromArray( uvs, a * 2 );
-			uvB.fromArray( uvs, b * 2 );
-			uvC.fromArray( uvs, c * 2 );
-
-			vB.sub( vA );
-			vC.sub( vA );
-
-			uvB.sub( uvA );
-			uvC.sub( uvA );
-
-			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );
-
-			// silently ignore degenerate uv triangles having coincident or colinear vertices
-
-			if ( ! isFinite( r ) ) return;
-
-			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
-			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );
-
-			tan1[ a ].add( sdir );
-			tan1[ b ].add( sdir );
-			tan1[ c ].add( sdir );
-
-			tan2[ a ].add( tdir );
-			tan2[ b ].add( tdir );
-			tan2[ c ].add( tdir );
-
-		}
-
-		let groups = this.groups;
-
-		if ( groups.length === 0 ) {
-
-			groups = [ {
-				start: 0,
-				count: indices.length
-			} ];
-
-		}
-
-		for ( let i = 0, il = groups.length; i < il; ++ i ) {
-
-			const group = groups[ i ];
-
-			const start = group.start;
-			const count = group.count;
-
-			for ( let j = start, jl = start + count; j < jl; j += 3 ) {
-
-				handleTriangle(
-					indices[ j + 0 ],
-					indices[ j + 1 ],
-					indices[ j + 2 ]
-				);
-
-			}
-
-		}
-
-		const tmp = new Vector3(), tmp2 = new Vector3();
-		const n = new Vector3(), n2 = new Vector3();
-
-		function handleVertex( v ) {
-
-			n.fromArray( normals, v * 3 );
-			n2.copy( n );
-
-			const t = tan1[ v ];
-
-			// Gram-Schmidt orthogonalize
-
-			tmp.copy( t );
-			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();
-
-			// Calculate handedness
-
-			tmp2.crossVectors( n2, t );
-			const test = tmp2.dot( tan2[ v ] );
-			const w = ( test < 0.0 ) ? - 1.0 : 1.0;
-
-			tangents[ v * 4 ] = tmp.x;
-			tangents[ v * 4 + 1 ] = tmp.y;
-			tangents[ v * 4 + 2 ] = tmp.z;
-			tangents[ v * 4 + 3 ] = w;
-
-		}
-
-		for ( let i = 0, il = groups.length; i < il; ++ i ) {
-
-			const group = groups[ i ];
-
-			const start = group.start;
-			const count = group.count;
-
-			for ( let j = start, jl = start + count; j < jl; j += 3 ) {
-
-				handleVertex( indices[ j + 0 ] );
-				handleVertex( indices[ j + 1 ] );
-				handleVertex( indices[ j + 2 ] );
-
-			}
-
-		}
-
-	}
-
-	computeVertexNormals() {
-
-		const index = this.index;
-		const positionAttribute = this.getAttribute( 'position' );
-
-		if ( positionAttribute !== undefined ) {
-
-			let normalAttribute = this.getAttribute( 'normal' );
-
-			if ( normalAttribute === undefined ) {
-
-				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
-				this.setAttribute( 'normal', normalAttribute );
-
-			} else {
-
-				// reset existing normals to zero
-
-				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {
-
-					normalAttribute.setXYZ( i, 0, 0, 0 );
-
-				}
-
-			}
-
-			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
-			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
-			const cb = new Vector3(), ab = new Vector3();
-
-			// indexed elements
-
-			if ( index ) {
-
-				for ( let i = 0, il = index.count; i < il; i += 3 ) {
-
-					const vA = index.getX( i + 0 );
-					const vB = index.getX( i + 1 );
-					const vC = index.getX( i + 2 );
-
-					pA.fromBufferAttribute( positionAttribute, vA );
-					pB.fromBufferAttribute( positionAttribute, vB );
-					pC.fromBufferAttribute( positionAttribute, vC );
-
-					cb.subVectors( pC, pB );
-					ab.subVectors( pA, pB );
-					cb.cross( ab );
-
-					nA.fromBufferAttribute( normalAttribute, vA );
-					nB.fromBufferAttribute( normalAttribute, vB );
-					nC.fromBufferAttribute( normalAttribute, vC );
-
-					nA.add( cb );
-					nB.add( cb );
-					nC.add( cb );
-
-					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
-					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
-					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );
-
-				}
-
-			} else {
-
-				// non-indexed elements (unconnected triangle soup)
-
-				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {
-
-					pA.fromBufferAttribute( positionAttribute, i + 0 );
-					pB.fromBufferAttribute( positionAttribute, i + 1 );
-					pC.fromBufferAttribute( positionAttribute, i + 2 );
-
-					cb.subVectors( pC, pB );
-					ab.subVectors( pA, pB );
-					cb.cross( ab );
-
-					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
-					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
-					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );
-
-				}
-
-			}
-
-			this.normalizeNormals();
-
-			normalAttribute.needsUpdate = true;
-
-		}
-
-	}
-
-	merge( geometry, offset ) {
-
-		if ( ! ( geometry && geometry.isBufferGeometry ) ) {
-
-			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
-			return;
-
-		}
-
-		if ( offset === undefined ) {
-
-			offset = 0;
-
-			console.warn(
-				'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
-				+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
-			);
-
-		}
-
-		const attributes = this.attributes;
-
-		for ( const key in attributes ) {
-
-			if ( geometry.attributes[ key ] === undefined ) continue;
-
-			const attribute1 = attributes[ key ];
-			const attributeArray1 = attribute1.array;
-
-			const attribute2 = geometry.attributes[ key ];
-			const attributeArray2 = attribute2.array;
-
-			const attributeOffset = attribute2.itemSize * offset;
-			const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );
-
-			for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {
-
-				attributeArray1[ j ] = attributeArray2[ i ];
-
-			}
-
-		}
-
-		return this;
-
-	}
-
-	normalizeNormals() {
-
-		const normals = this.attributes.normal;
-
-		for ( let i = 0, il = normals.count; i < il; i ++ ) {
-
-			_vector.fromBufferAttribute( normals, i );
-
-			_vector.normalize();
-
-			normals.setXYZ( i, _vector.x, _vector.y, _vector.z );
-
-		}
-
-	}
-
-	toNonIndexed() {
-
-		function convertBufferAttribute( attribute, indices ) {
-
-			const array = attribute.array;
-			const itemSize = attribute.itemSize;
-			const normalized = attribute.normalized;
-
-			const array2 = new array.constructor( indices.length * itemSize );
-
-			let index = 0, index2 = 0;
-
-			for ( let i = 0, l = indices.length; i < l; i ++ ) {
-
-				if ( attribute.isInterleavedBufferAttribute ) {
-
-					index = indices[ i ] * attribute.data.stride + attribute.offset;
-
-				} else {
-
-					index = indices[ i ] * itemSize;
-
-				}
-
-				for ( let j = 0; j < itemSize; j ++ ) {
-
-					array2[ index2 ++ ] = array[ index ++ ];
-
-				}
-
-			}
-
-			return new BufferAttribute( array2, itemSize, normalized );
-
-		}
-
-		//
-
-		if ( this.index === null ) {
-
-			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
-			return this;
-
-		}
-
-		const geometry2 = new BufferGeometry();
-
-		const indices = this.index.array;
-		const attributes = this.attributes;
-
-		// attributes
-
-		for ( const name in attributes ) {
-
-			const attribute = attributes[ name ];
-
-			const newAttribute = convertBufferAttribute( attribute, indices );
-
-			geometry2.setAttribute( name, newAttribute );
-
-		}
-
-		// morph attributes
-
-		const morphAttributes = this.morphAttributes;
-
-		for ( const name in morphAttributes ) {
-
-			const morphArray = [];
-			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes
-
-			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {
-
-				const attribute = morphAttribute[ i ];
-
-				const newAttribute = convertBufferAttribute( attribute, indices );
-
-				morphArray.push( newAttribute );
-
-			}
-
-			geometry2.morphAttributes[ name ] = morphArray;
-
-		}
-
-		geometry2.morphTargetsRelative = this.morphTargetsRelative;
-
-		// groups
-
-		const groups = this.groups;
-
-		for ( let i = 0, l = groups.length; i < l; i ++ ) {
-
-			const group = groups[ i ];
-			geometry2.addGroup( group.start, group.count, group.materialIndex );
-
-		}
-
-		return geometry2;
-
-	}
-
-	toJSON() {
-
-		const data = {
-			metadata: {
-				version: 4.5,
-				type: 'BufferGeometry',
-				generator: 'BufferGeometry.toJSON'
-			}
-		};
-
-		// standard BufferGeometry serialization
-
-		data.uuid = this.uuid;
-		data.type = this.type;
-		if ( this.name !== '' ) data.name = this.name;
-		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;
-
-		if ( this.parameters !== undefined ) {
-
-			const parameters = this.parameters;
-
-			for ( const key in parameters ) {
-
-				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
-
-			}
-
-			return data;
-
-		}
-
-		// for simplicity the code assumes attributes are not shared across geometries, see #15811
-
-		data.data = { attributes: {} };
-
-		const index = this.index;
-
-		if ( index !== null ) {
-
-			data.data.index = {
-				type: index.array.constructor.name,
-				array: Array.prototype.slice.call( index.array )
-			};
-
-		}
-
-		const attributes = this.attributes;
-
-		for ( const key in attributes ) {
-
-			const attribute = attributes[ key ];
-
-			data.data.attributes[ key ] = attribute.toJSON( data.data );
-
-		}
-
-		const morphAttributes = {};
-		let hasMorphAttributes = false;
-
-		for ( const key in this.morphAttributes ) {
-
-			const attributeArray = this.morphAttributes[ key ];
-
-			const array = [];
-
-			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {
-
-				const attribute = attributeArray[ i ];
-
-				array.push( attribute.toJSON( data.data ) );
-
-			}
-
-			if ( array.length > 0 ) {
-
-				morphAttributes[ key ] = array;
-
-				hasMorphAttributes = true;
-
-			}
-
-		}
-
-		if ( hasMorphAttributes ) {
-
-			data.data.morphAttributes = morphAttributes;
-			data.data.morphTargetsRelative = this.morphTargetsRelative;
-
-		}
-
-		const groups = this.groups;
-
-		if ( groups.length > 0 ) {
-
-			data.data.groups = JSON.parse( JSON.stringify( groups ) );
-
-		}
-
-		const boundingSphere = this.boundingSphere;
-
-		if ( boundingSphere !== null ) {
-
-			data.data.boundingSphere = {
-				center: boundingSphere.center.toArray(),
-				radius: boundingSphere.radius
-			};
-
-		}
-
-		return data;
-
-	}
-
-	clone() {
-
-		 return new this.constructor().copy( this );
-
-	}
-
-	copy( source ) {
-
-		// reset
-
-		this.index = null;
-		this.attributes = {};
-		this.morphAttributes = {};
-		this.groups = [];
-		this.boundingBox = null;
-		this.boundingSphere = null;
-
-		// used for storing cloned, shared data
-
-		const data = {};
-
-		// name
-
-		this.name = source.name;
-
-		// index
-
-		const index = source.index;
-
-		if ( index !== null ) {
-
-			this.setIndex( index.clone( data ) );
-
-		}
-
-		// attributes
-
-		const attributes = source.attributes;
-
-		for ( const name in attributes ) {
-
-			const attribute = attributes[ name ];
-			this.setAttribute( name, attribute.clone( data ) );
-
-		}
-
-		// morph attributes
-
-		const morphAttributes = source.morphAttributes;
-
-		for ( const name in morphAttributes ) {
-
-			const array = [];
-			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes
-
-			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {
-
-				array.push( morphAttribute[ i ].clone( data ) );
-
-			}
-
-			this.morphAttributes[ name ] = array;
-
-		}
-
-		this.morphTargetsRelative = source.morphTargetsRelative;
-
-		// groups
-
-		const groups = source.groups;
-
-		for ( let i = 0, l = groups.length; i < l; i ++ ) {
-
-			const group = groups[ i ];
-			this.addGroup( group.start, group.count, group.materialIndex );
-
-		}
-
-		// bounding box
-
-		const boundingBox = source.boundingBox;
-
-		if ( boundingBox !== null ) {
-
-			this.boundingBox = boundingBox.clone();
-
-		}
-
-		// bounding sphere
-
-		const boundingSphere = source.boundingSphere;
-
-		if ( boundingSphere !== null ) {
-
-			this.boundingSphere = boundingSphere.clone();
-
-		}
-
-		// draw range
-
-		this.drawRange.start = source.drawRange.start;
-		this.drawRange.count = source.drawRange.count;
-
-		// user data
-
-		this.userData = source.userData;
-
-		// geometry generator parameters
-
-		if ( source.parameters !== undefined ) this.parameters = Object.assign( {}, source.parameters );
-
-		return this;
-
-	}
-
-	dispose() {
-
-		this.dispatchEvent( { type: 'dispose' } );
-
-	}
+        return this;
+    }
 
+    dispose() {
+        this.dispatchEvent({ type: "dispose" });
+    }
 }
 
 export { BufferGeometry };
diff --git a/node_modules/three/src/core/Object3D.js b/node_modules/three/src/core/Object3D.js
index ea06b54..3b459de 100644
--- a/node_modules/three/src/core/Object3D.js
+++ b/node_modules/three/src/core/Object3D.js
@@ -1,11 +1,11 @@
-import { Quaternion } from '../math/Quaternion.js';
-import { Vector3 } from '../math/Vector3.js';
-import { Matrix4 } from '../math/Matrix4.js';
-import { EventDispatcher } from './EventDispatcher.js';
-import { Euler } from '../math/Euler.js';
-import { Layers } from './Layers.js';
-import { Matrix3 } from '../math/Matrix3.js';
-import * as MathUtils from '../math/MathUtils.js';
+import { Quaternion } from "../math/Quaternion.js";
+import { Vector3 } from "../math/Vector3.js";
+import { Matrix4 } from "../math/Matrix4.js";
+import { EventDispatcher } from "./EventDispatcher.js";
+import { Euler } from "../math/Euler.js";
+import { Layers } from "./Layers.js";
+import { Matrix3 } from "../math/Matrix3.js";
+import * as MathUtils from "../math/MathUtils.js";
 
 let _object3DId = 0;
 
@@ -18,910 +18,721 @@ const _position = /*@__PURE__*/ new Vector3();
 const _scale = /*@__PURE__*/ new Vector3();
 const _quaternion = /*@__PURE__*/ new Quaternion();
 
-const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
-const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
-const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );
+const _xAxis = /*@__PURE__*/ new Vector3(1, 0, 0);
+const _yAxis = /*@__PURE__*/ new Vector3(0, 1, 0);
+const _zAxis = /*@__PURE__*/ new Vector3(0, 0, 1);
 
-const _addedEvent = { type: 'added' };
-const _removedEvent = { type: 'removed' };
+const _addedEvent = { type: "added" };
+const _removedEvent = { type: "removed" };
 
 class Object3D extends EventDispatcher {
+    constructor() {
+        super();
 
-	constructor() {
+        this.isObject3D = true;
 
-		super();
+        Object.defineProperty(this, "id", { value: _object3DId++ });
 
-		this.isObject3D = true;
+        this.uuid = MathUtils.generateUUID();
 
-		Object.defineProperty( this, 'id', { value: _object3DId ++ } );
+        this.name = "";
+        this.type = "Object3D";
 
-		this.uuid = MathUtils.generateUUID();
+        this.parent = null;
+        this.children = [];
 
-		this.name = '';
-		this.type = 'Object3D';
+        this.up = Object3D.DefaultUp.clone();
 
-		this.parent = null;
-		this.children = [];
+        const position = new Vector3();
+        const rotation = new Euler();
+        const quaternion = new Quaternion();
+        const scale = new Vector3(1, 1, 1);
 
-		this.up = Object3D.DefaultUp.clone();
+        function onRotationChange() {
+            quaternion.setFromEuler(rotation, false);
+        }
 
-		const position = new Vector3();
-		const rotation = new Euler();
-		const quaternion = new Quaternion();
-		const scale = new Vector3( 1, 1, 1 );
+        function onQuaternionChange() {
+            rotation.setFromQuaternion(quaternion, undefined, false);
+        }
 
-		function onRotationChange() {
+        rotation._onChange(onRotationChange);
+        quaternion._onChange(onQuaternionChange);
 
-			quaternion.setFromEuler( rotation, false );
+        Object.defineProperties(this, {
+            position: {
+                configurable: true,
+                enumerable: true,
+                value: position,
+                writable: true,
+            },
+            rotation: {
+                configurable: true,
+                enumerable: true,
+                value: rotation,
+                writable: true,
+            },
+            quaternion: {
+                configurable: true,
+                enumerable: true,
+                value: quaternion,
+                writable: true,
+            },
+            scale: {
+                configurable: true,
+                enumerable: true,
+                value: scale,
+                writable: true,
+            },
+            modelViewMatrix: {
+                value: new Matrix4(),
+            },
+            normalMatrix: {
+                value: new Matrix3(),
+            },
+        });
 
-		}
+        this.matrix = new Matrix4();
+        this.matrixWorld = new Matrix4();
 
-		function onQuaternionChange() {
+        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
+        this.matrixWorldNeedsUpdate = false;
 
-			rotation.setFromQuaternion( quaternion, undefined, false );
+        this.layers = new Layers();
+        this.visible = true;
 
-		}
+        this.castShadow = false;
+        this.receiveShadow = false;
 
-		rotation._onChange( onRotationChange );
-		quaternion._onChange( onQuaternionChange );
+        this.frustumCulled = true;
+        this.renderOrder = 0;
 
-		Object.defineProperties( this, {
-			position: {
-				configurable: true,
-				enumerable: true,
-				value: position
-			},
-			rotation: {
-				configurable: true,
-				enumerable: true,
-				value: rotation
-			},
-			quaternion: {
-				configurable: true,
-				enumerable: true,
-				value: quaternion
-			},
-			scale: {
-				configurable: true,
-				enumerable: true,
-				value: scale
-			},
-			modelViewMatrix: {
-				value: new Matrix4()
-			},
-			normalMatrix: {
-				value: new Matrix3()
-			}
-		} );
+        this.animations = [];
 
-		this.matrix = new Matrix4();
-		this.matrixWorld = new Matrix4();
+        this.userData = {};
+    }
 
-		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
-		this.matrixWorldNeedsUpdate = false;
+    onBeforeRender(/* renderer, scene, camera, geometry, material, group */) {}
 
-		this.layers = new Layers();
-		this.visible = true;
+    onAfterRender(/* renderer, scene, camera, geometry, material, group */) {}
 
-		this.castShadow = false;
-		this.receiveShadow = false;
+    applyMatrix4(matrix) {
+        if (this.matrixAutoUpdate) this.updateMatrix();
 
-		this.frustumCulled = true;
-		this.renderOrder = 0;
+        this.matrix.premultiply(matrix);
 
-		this.animations = [];
+        this.matrix.decompose(this.position, this.quaternion, this.scale);
+    }
 
-		this.userData = {};
+    applyQuaternion(q) {
+        this.quaternion.premultiply(q);
 
-	}
+        return this;
+    }
 
-	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}
+    setRotationFromAxisAngle(axis, angle) {
+        // assumes axis is normalized
 
-	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}
+        this.quaternion.setFromAxisAngle(axis, angle);
+    }
 
-	applyMatrix4( matrix ) {
+    setRotationFromEuler(euler) {
+        this.quaternion.setFromEuler(euler, true);
+    }
 
-		if ( this.matrixAutoUpdate ) this.updateMatrix();
+    setRotationFromMatrix(m) {
+        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
 
-		this.matrix.premultiply( matrix );
+        this.quaternion.setFromRotationMatrix(m);
+    }
 
-		this.matrix.decompose( this.position, this.quaternion, this.scale );
+    setRotationFromQuaternion(q) {
+        // assumes q is normalized
 
-	}
+        this.quaternion.copy(q);
+    }
 
-	applyQuaternion( q ) {
+    rotateOnAxis(axis, angle) {
+        // rotate object on axis in object space
+        // axis is assumed to be normalized
 
-		this.quaternion.premultiply( q );
+        _q1.setFromAxisAngle(axis, angle);
 
-		return this;
+        this.quaternion.multiply(_q1);
 
-	}
+        return this;
+    }
 
-	setRotationFromAxisAngle( axis, angle ) {
+    rotateOnWorldAxis(axis, angle) {
+        // rotate object on axis in world space
+        // axis is assumed to be normalized
+        // method assumes no rotated parent
 
-		// assumes axis is normalized
+        _q1.setFromAxisAngle(axis, angle);
 
-		this.quaternion.setFromAxisAngle( axis, angle );
+        this.quaternion.premultiply(_q1);
 
-	}
+        return this;
+    }
 
-	setRotationFromEuler( euler ) {
+    rotateX(angle) {
+        return this.rotateOnAxis(_xAxis, angle);
+    }
 
-		this.quaternion.setFromEuler( euler, true );
+    rotateY(angle) {
+        return this.rotateOnAxis(_yAxis, angle);
+    }
 
-	}
+    rotateZ(angle) {
+        return this.rotateOnAxis(_zAxis, angle);
+    }
 
-	setRotationFromMatrix( m ) {
+    translateOnAxis(axis, distance) {
+        // translate object by distance along axis in object space
+        // axis is assumed to be normalized
 
-		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
+        _v1.copy(axis).applyQuaternion(this.quaternion);
 
-		this.quaternion.setFromRotationMatrix( m );
+        this.position.add(_v1.multiplyScalar(distance));
 
-	}
+        return this;
+    }
 
-	setRotationFromQuaternion( q ) {
+    translateX(distance) {
+        return this.translateOnAxis(_xAxis, distance);
+    }
 
-		// assumes q is normalized
+    translateY(distance) {
+        return this.translateOnAxis(_yAxis, distance);
+    }
 
-		this.quaternion.copy( q );
+    translateZ(distance) {
+        return this.translateOnAxis(_zAxis, distance);
+    }
 
-	}
+    localToWorld(vector) {
+        return vector.applyMatrix4(this.matrixWorld);
+    }
 
-	rotateOnAxis( axis, angle ) {
+    worldToLocal(vector) {
+        return vector.applyMatrix4(_m1.copy(this.matrixWorld).invert());
+    }
 
-		// rotate object on axis in object space
-		// axis is assumed to be normalized
+    lookAt(x, y, z) {
+        // This method does not support objects having non-uniformly-scaled parent(s)
 
-		_q1.setFromAxisAngle( axis, angle );
+        if (x.isVector3) {
+            _target.copy(x);
+        } else {
+            _target.set(x, y, z);
+        }
 
-		this.quaternion.multiply( _q1 );
+        const parent = this.parent;
 
-		return this;
+        this.updateWorldMatrix(true, false);
 
-	}
+        _position.setFromMatrixPosition(this.matrixWorld);
 
-	rotateOnWorldAxis( axis, angle ) {
+        if (this.isCamera || this.isLight) {
+            _m1.lookAt(_position, _target, this.up);
+        } else {
+            _m1.lookAt(_target, _position, this.up);
+        }
 
-		// rotate object on axis in world space
-		// axis is assumed to be normalized
-		// method assumes no rotated parent
+        this.quaternion.setFromRotationMatrix(_m1);
 
-		_q1.setFromAxisAngle( axis, angle );
+        if (parent) {
+            _m1.extractRotation(parent.matrixWorld);
+            _q1.setFromRotationMatrix(_m1);
+            this.quaternion.premultiply(_q1.invert());
+        }
+    }
 
-		this.quaternion.premultiply( _q1 );
+    add(object) {
+        if (arguments.length > 1) {
+            for (let i = 0; i < arguments.length; i++) {
+                this.add(arguments[i]);
+            }
 
-		return this;
+            return this;
+        }
 
-	}
+        if (object === this) {
+            console.error(
+                "THREE.Object3D.add: object can't be added as a child of itself.",
+                object
+            );
+            return this;
+        }
 
-	rotateX( angle ) {
+        if (object && object.isObject3D) {
+            if (object.parent !== null) {
+                object.parent.remove(object);
+            }
 
-		return this.rotateOnAxis( _xAxis, angle );
+            object.parent = this;
+            this.children.push(object);
 
-	}
+            object.dispatchEvent(_addedEvent);
+        } else {
+            console.error(
+                "THREE.Object3D.add: object not an instance of THREE.Object3D.",
+                object
+            );
+        }
 
-	rotateY( angle ) {
+        return this;
+    }
 
-		return this.rotateOnAxis( _yAxis, angle );
+    remove(object) {
+        if (arguments.length > 1) {
+            for (let i = 0; i < arguments.length; i++) {
+                this.remove(arguments[i]);
+            }
 
-	}
+            return this;
+        }
 
-	rotateZ( angle ) {
+        const index = this.children.indexOf(object);
 
-		return this.rotateOnAxis( _zAxis, angle );
+        if (index !== -1) {
+            object.parent = null;
+            this.children.splice(index, 1);
 
-	}
+            object.dispatchEvent(_removedEvent);
+        }
 
-	translateOnAxis( axis, distance ) {
+        return this;
+    }
 
-		// translate object by distance along axis in object space
-		// axis is assumed to be normalized
+    removeFromParent() {
+        const parent = this.parent;
 
-		_v1.copy( axis ).applyQuaternion( this.quaternion );
+        if (parent !== null) {
+            parent.remove(this);
+        }
 
-		this.position.add( _v1.multiplyScalar( distance ) );
+        return this;
+    }
 
-		return this;
+    clear() {
+        for (let i = 0; i < this.children.length; i++) {
+            const object = this.children[i];
 
-	}
+            object.parent = null;
 
-	translateX( distance ) {
+            object.dispatchEvent(_removedEvent);
+        }
 
-		return this.translateOnAxis( _xAxis, distance );
+        this.children.length = 0;
 
-	}
+        return this;
+    }
 
-	translateY( distance ) {
+    attach(object) {
+        // adds object as a child of this, while maintaining the object's world transform
 
-		return this.translateOnAxis( _yAxis, distance );
+        // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
 
-	}
+        this.updateWorldMatrix(true, false);
 
-	translateZ( distance ) {
+        _m1.copy(this.matrixWorld).invert();
 
-		return this.translateOnAxis( _zAxis, distance );
+        if (object.parent !== null) {
+            object.parent.updateWorldMatrix(true, false);
 
-	}
+            _m1.multiply(object.parent.matrixWorld);
+        }
 
-	localToWorld( vector ) {
+        object.applyMatrix4(_m1);
 
-		return vector.applyMatrix4( this.matrixWorld );
+        this.add(object);
 
-	}
+        object.updateWorldMatrix(false, true);
 
-	worldToLocal( vector ) {
+        return this;
+    }
 
-		return vector.applyMatrix4( _m1.copy( this.matrixWorld ).invert() );
+    getObjectById(id) {
+        return this.getObjectByProperty("id", id);
+    }
 
-	}
+    getObjectByName(name) {
+        return this.getObjectByProperty("name", name);
+    }
 
-	lookAt( x, y, z ) {
+    getObjectByProperty(name, value) {
+        if (this[name] === value) return this;
 
-		// This method does not support objects having non-uniformly-scaled parent(s)
+        for (let i = 0, l = this.children.length; i < l; i++) {
+            const child = this.children[i];
+            const object = child.getObjectByProperty(name, value);
 
-		if ( x.isVector3 ) {
+            if (object !== undefined) {
+                return object;
+            }
+        }
 
-			_target.copy( x );
+        return undefined;
+    }
 
-		} else {
+    getWorldPosition(target) {
+        this.updateWorldMatrix(true, false);
 
-			_target.set( x, y, z );
+        return target.setFromMatrixPosition(this.matrixWorld);
+    }
 
-		}
+    getWorldQuaternion(target) {
+        this.updateWorldMatrix(true, false);
 
-		const parent = this.parent;
+        this.matrixWorld.decompose(_position, target, _scale);
 
-		this.updateWorldMatrix( true, false );
+        return target;
+    }
 
-		_position.setFromMatrixPosition( this.matrixWorld );
+    getWorldScale(target) {
+        this.updateWorldMatrix(true, false);
 
-		if ( this.isCamera || this.isLight ) {
+        this.matrixWorld.decompose(_position, _quaternion, target);
 
-			_m1.lookAt( _position, _target, this.up );
+        return target;
+    }
 
-		} else {
+    getWorldDirection(target) {
+        this.updateWorldMatrix(true, false);
 
-			_m1.lookAt( _target, _position, this.up );
+        const e = this.matrixWorld.elements;
 
-		}
+        return target.set(e[8], e[9], e[10]).normalize();
+    }
 
-		this.quaternion.setFromRotationMatrix( _m1 );
+    raycast(/* raycaster, intersects */) {}
 
-		if ( parent ) {
+    traverse(callback) {
+        callback(this);
 
-			_m1.extractRotation( parent.matrixWorld );
-			_q1.setFromRotationMatrix( _m1 );
-			this.quaternion.premultiply( _q1.invert() );
+        const children = this.children;
 
-		}
+        for (let i = 0, l = children.length; i < l; i++) {
+            children[i].traverse(callback);
+        }
+    }
 
-	}
+    traverseVisible(callback) {
+        if (this.visible === false) return;
 
-	add( object ) {
+        callback(this);
 
-		if ( arguments.length > 1 ) {
+        const children = this.children;
 
-			for ( let i = 0; i < arguments.length; i ++ ) {
+        for (let i = 0, l = children.length; i < l; i++) {
+            children[i].traverseVisible(callback);
+        }
+    }
 
-				this.add( arguments[ i ] );
+    traverseAncestors(callback) {
+        const parent = this.parent;
 
-			}
+        if (parent !== null) {
+            callback(parent);
 
-			return this;
+            parent.traverseAncestors(callback);
+        }
+    }
 
-		}
+    updateMatrix() {
+        this.matrix.compose(this.position, this.quaternion, this.scale);
 
-		if ( object === this ) {
+        this.matrixWorldNeedsUpdate = true;
+    }
 
-			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
-			return this;
+    updateMatrixWorld(force) {
+        if (this.matrixAutoUpdate) this.updateMatrix();
 
-		}
+        if (this.matrixWorldNeedsUpdate || force) {
+            if (this.parent === null) {
+                this.matrixWorld.copy(this.matrix);
+            } else {
+                this.matrixWorld.multiplyMatrices(
+                    this.parent.matrixWorld,
+                    this.matrix
+                );
+            }
 
-		if ( object && object.isObject3D ) {
+            this.matrixWorldNeedsUpdate = false;
 
-			if ( object.parent !== null ) {
+            force = true;
+        }
 
-				object.parent.remove( object );
+        // update children
 
-			}
+        const children = this.children;
 
-			object.parent = this;
-			this.children.push( object );
+        for (let i = 0, l = children.length; i < l; i++) {
+            children[i].updateMatrixWorld(force);
+        }
+    }
 
-			object.dispatchEvent( _addedEvent );
+    updateWorldMatrix(updateParents, updateChildren) {
+        const parent = this.parent;
 
-		} else {
+        if (updateParents === true && parent !== null) {
+            parent.updateWorldMatrix(true, false);
+        }
 
-			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );
+        if (this.matrixAutoUpdate) this.updateMatrix();
 
-		}
+        if (this.parent === null) {
+            this.matrixWorld.copy(this.matrix);
+        } else {
+            this.matrixWorld.multiplyMatrices(
+                this.parent.matrixWorld,
+                this.matrix
+            );
+        }
 
-		return this;
+        // update children
 
-	}
+        if (updateChildren === true) {
+            const children = this.children;
 
-	remove( object ) {
+            for (let i = 0, l = children.length; i < l; i++) {
+                children[i].updateWorldMatrix(false, true);
+            }
+        }
+    }
+
+    toJSON(meta) {
+        // meta is a string when called from JSON.stringify
+        const isRootObject = meta === undefined || typeof meta === "string";
+
+        const output = {};
+
+        // meta is a hash used to collect geometries, materials.
+        // not providing it implies that this is the root object
+        // being serialized.
+        if (isRootObject) {
+            // initialize meta obj
+            meta = {
+                geometries: {},
+                materials: {},
+                textures: {},
+                images: {},
+                shapes: {},
+                skeletons: {},
+                animations: {},
+                nodes: {},
+            };
+
+            output.metadata = {
+                version: 4.5,
+                type: "Object",
+                generator: "Object3D.toJSON",
+            };
+        }
+
+        // standard Object3D serialization
+
+        const object = {};
+
+        object.uuid = this.uuid;
+        object.type = this.type;
+
+        if (this.name !== "") object.name = this.name;
+        if (this.castShadow === true) object.castShadow = true;
+        if (this.receiveShadow === true) object.receiveShadow = true;
+        if (this.visible === false) object.visible = false;
+        if (this.frustumCulled === false) object.frustumCulled = false;
+        if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
+        if (JSON.stringify(this.userData) !== "{}")
+            object.userData = this.userData;
+
+        object.layers = this.layers.mask;
+        object.matrix = this.matrix.toArray();
+
+        if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
+
+        // object specific properties
+
+        if (this.isInstancedMesh) {
+            object.type = "InstancedMesh";
+            object.count = this.count;
+            object.instanceMatrix = this.instanceMatrix.toJSON();
+            if (this.instanceColor !== null)
+                object.instanceColor = this.instanceColor.toJSON();
+        }
+
+        //
+
+        function serialize(library, element) {
+            if (library[element.uuid] === undefined) {
+                library[element.uuid] = element.toJSON(meta);
+            }
+
+            return element.uuid;
+        }
+
+        if (this.isScene) {
+            if (this.background) {
+                if (this.background.isColor) {
+                    object.background = this.background.toJSON();
+                } else if (this.background.isTexture) {
+                    object.background = this.background.toJSON(meta).uuid;
+                }
+            }
+
+            if (this.environment && this.environment.isTexture) {
+                object.environment = this.environment.toJSON(meta).uuid;
+            }
+        } else if (this.isMesh || this.isLine || this.isPoints) {
+            object.geometry = serialize(meta.geometries, this.geometry);
+
+            const parameters = this.geometry.parameters;
+
+            if (parameters !== undefined && parameters.shapes !== undefined) {
+                const shapes = parameters.shapes;
+
+                if (Array.isArray(shapes)) {
+                    for (let i = 0, l = shapes.length; i < l; i++) {
+                        const shape = shapes[i];
+
+                        serialize(meta.shapes, shape);
+                    }
+                } else {
+                    serialize(meta.shapes, shapes);
+                }
+            }
+        }
+
+        if (this.isSkinnedMesh) {
+            object.bindMode = this.bindMode;
+            object.bindMatrix = this.bindMatrix.toArray();
+
+            if (this.skeleton !== undefined) {
+                serialize(meta.skeletons, this.skeleton);
+
+                object.skeleton = this.skeleton.uuid;
+            }
+        }
+
+        if (this.material !== undefined) {
+            if (Array.isArray(this.material)) {
+                const uuids = [];
+
+                for (let i = 0, l = this.material.length; i < l; i++) {
+                    uuids.push(serialize(meta.materials, this.material[i]));
+                }
+
+                object.material = uuids;
+            } else {
+                object.material = serialize(meta.materials, this.material);
+            }
+        }
+
+        //
+
+        if (this.children.length > 0) {
+            object.children = [];
+
+            for (let i = 0; i < this.children.length; i++) {
+                object.children.push(this.children[i].toJSON(meta).object);
+            }
+        }
+
+        //
+
+        if (this.animations.length > 0) {
+            object.animations = [];
+
+            for (let i = 0; i < this.animations.length; i++) {
+                const animation = this.animations[i];
+
+                object.animations.push(serialize(meta.animations, animation));
+            }
+        }
+
+        if (isRootObject) {
+            const geometries = extractFromCache(meta.geometries);
+            const materials = extractFromCache(meta.materials);
+            const textures = extractFromCache(meta.textures);
+            const images = extractFromCache(meta.images);
+            const shapes = extractFromCache(meta.shapes);
+            const skeletons = extractFromCache(meta.skeletons);
+            const animations = extractFromCache(meta.animations);
+            const nodes = extractFromCache(meta.nodes);
+
+            if (geometries.length > 0) output.geometries = geometries;
+            if (materials.length > 0) output.materials = materials;
+            if (textures.length > 0) output.textures = textures;
+            if (images.length > 0) output.images = images;
+            if (shapes.length > 0) output.shapes = shapes;
+            if (skeletons.length > 0) output.skeletons = skeletons;
+            if (animations.length > 0) output.animations = animations;
+            if (nodes.length > 0) output.nodes = nodes;
+        }
+
+        output.object = object;
+
+        return output;
+
+        // extract data from the cache hash
+        // remove metadata on each item
+        // and return as array
+        function extractFromCache(cache) {
+            const values = [];
+            for (const key in cache) {
+                const data = cache[key];
+                delete data.metadata;
+                values.push(data);
+            }
+
+            return values;
+        }
+    }
+
+    clone(recursive) {
+        return new this.constructor().copy(this, recursive);
+    }
+
+    copy(source, recursive = true) {
+        this.name = source.name;
+
+        this.up.copy(source.up);
+
+        this.position.copy(source.position);
+        this.rotation.order = source.rotation.order;
+        this.quaternion.copy(source.quaternion);
+        this.scale.copy(source.scale);
 
-		if ( arguments.length > 1 ) {
-
-			for ( let i = 0; i < arguments.length; i ++ ) {
-
-				this.remove( arguments[ i ] );
-
-			}
-
-			return this;
-
-		}
-
-		const index = this.children.indexOf( object );
-
-		if ( index !== - 1 ) {
-
-			object.parent = null;
-			this.children.splice( index, 1 );
-
-			object.dispatchEvent( _removedEvent );
-
-		}
-
-		return this;
-
-	}
-
-	removeFromParent() {
-
-		const parent = this.parent;
-
-		if ( parent !== null ) {
-
-			parent.remove( this );
-
-		}
-
-		return this;
-
-	}
-
-	clear() {
-
-		for ( let i = 0; i < this.children.length; i ++ ) {
-
-			const object = this.children[ i ];
-
-			object.parent = null;
-
-			object.dispatchEvent( _removedEvent );
-
-		}
-
-		this.children.length = 0;
-
-		return this;
-
-
-	}
-
-	attach( object ) {
-
-		// adds object as a child of this, while maintaining the object's world transform
-
-		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
-
-		this.updateWorldMatrix( true, false );
-
-		_m1.copy( this.matrixWorld ).invert();
-
-		if ( object.parent !== null ) {
-
-			object.parent.updateWorldMatrix( true, false );
-
-			_m1.multiply( object.parent.matrixWorld );
-
-		}
-
-		object.applyMatrix4( _m1 );
-
-		this.add( object );
-
-		object.updateWorldMatrix( false, true );
-
-		return this;
-
-	}
-
-	getObjectById( id ) {
-
-		return this.getObjectByProperty( 'id', id );
-
-	}
-
-	getObjectByName( name ) {
-
-		return this.getObjectByProperty( 'name', name );
-
-	}
-
-	getObjectByProperty( name, value ) {
-
-		if ( this[ name ] === value ) return this;
-
-		for ( let i = 0, l = this.children.length; i < l; i ++ ) {
-
-			const child = this.children[ i ];
-			const object = child.getObjectByProperty( name, value );
-
-			if ( object !== undefined ) {
-
-				return object;
-
-			}
-
-		}
-
-		return undefined;
-
-	}
-
-	getWorldPosition( target ) {
-
-		this.updateWorldMatrix( true, false );
-
-		return target.setFromMatrixPosition( this.matrixWorld );
-
-	}
-
-	getWorldQuaternion( target ) {
-
-		this.updateWorldMatrix( true, false );
-
-		this.matrixWorld.decompose( _position, target, _scale );
-
-		return target;
-
-	}
-
-	getWorldScale( target ) {
-
-		this.updateWorldMatrix( true, false );
-
-		this.matrixWorld.decompose( _position, _quaternion, target );
-
-		return target;
-
-	}
-
-	getWorldDirection( target ) {
-
-		this.updateWorldMatrix( true, false );
-
-		const e = this.matrixWorld.elements;
-
-		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();
-
-	}
-
-	raycast( /* raycaster, intersects */ ) {}
-
-	traverse( callback ) {
-
-		callback( this );
-
-		const children = this.children;
-
-		for ( let i = 0, l = children.length; i < l; i ++ ) {
-
-			children[ i ].traverse( callback );
-
-		}
-
-	}
-
-	traverseVisible( callback ) {
-
-		if ( this.visible === false ) return;
-
-		callback( this );
-
-		const children = this.children;
-
-		for ( let i = 0, l = children.length; i < l; i ++ ) {
-
-			children[ i ].traverseVisible( callback );
-
-		}
-
-	}
-
-	traverseAncestors( callback ) {
-
-		const parent = this.parent;
-
-		if ( parent !== null ) {
-
-			callback( parent );
-
-			parent.traverseAncestors( callback );
-
-		}
-
-	}
-
-	updateMatrix() {
-
-		this.matrix.compose( this.position, this.quaternion, this.scale );
-
-		this.matrixWorldNeedsUpdate = true;
-
-	}
-
-	updateMatrixWorld( force ) {
-
-		if ( this.matrixAutoUpdate ) this.updateMatrix();
-
-		if ( this.matrixWorldNeedsUpdate || force ) {
-
-			if ( this.parent === null ) {
-
-				this.matrixWorld.copy( this.matrix );
-
-			} else {
-
-				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
-
-			}
-
-			this.matrixWorldNeedsUpdate = false;
-
-			force = true;
-
-		}
-
-		// update children
-
-		const children = this.children;
-
-		for ( let i = 0, l = children.length; i < l; i ++ ) {
-
-			children[ i ].updateMatrixWorld( force );
-
-		}
-
-	}
-
-	updateWorldMatrix( updateParents, updateChildren ) {
-
-		const parent = this.parent;
-
-		if ( updateParents === true && parent !== null ) {
-
-			parent.updateWorldMatrix( true, false );
-
-		}
-
-		if ( this.matrixAutoUpdate ) this.updateMatrix();
-
-		if ( this.parent === null ) {
-
-			this.matrixWorld.copy( this.matrix );
-
-		} else {
-
-			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
-
-		}
-
-		// update children
-
-		if ( updateChildren === true ) {
-
-			const children = this.children;
-
-			for ( let i = 0, l = children.length; i < l; i ++ ) {
-
-				children[ i ].updateWorldMatrix( false, true );
-
-			}
-
-		}
-
-	}
-
-	toJSON( meta ) {
-
-		// meta is a string when called from JSON.stringify
-		const isRootObject = ( meta === undefined || typeof meta === 'string' );
-
-		const output = {};
-
-		// meta is a hash used to collect geometries, materials.
-		// not providing it implies that this is the root object
-		// being serialized.
-		if ( isRootObject ) {
-
-			// initialize meta obj
-			meta = {
-				geometries: {},
-				materials: {},
-				textures: {},
-				images: {},
-				shapes: {},
-				skeletons: {},
-				animations: {},
-				nodes: {}
-			};
-
-			output.metadata = {
-				version: 4.5,
-				type: 'Object',
-				generator: 'Object3D.toJSON'
-			};
-
-		}
-
-		// standard Object3D serialization
-
-		const object = {};
-
-		object.uuid = this.uuid;
-		object.type = this.type;
-
-		if ( this.name !== '' ) object.name = this.name;
-		if ( this.castShadow === true ) object.castShadow = true;
-		if ( this.receiveShadow === true ) object.receiveShadow = true;
-		if ( this.visible === false ) object.visible = false;
-		if ( this.frustumCulled === false ) object.frustumCulled = false;
-		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
-		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
-
-		object.layers = this.layers.mask;
-		object.matrix = this.matrix.toArray();
-
-		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;
-
-		// object specific properties
-
-		if ( this.isInstancedMesh ) {
-
-			object.type = 'InstancedMesh';
-			object.count = this.count;
-			object.instanceMatrix = this.instanceMatrix.toJSON();
-			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();
-
-		}
-
-		//
-
-		function serialize( library, element ) {
-
-			if ( library[ element.uuid ] === undefined ) {
-
-				library[ element.uuid ] = element.toJSON( meta );
-
-			}
-
-			return element.uuid;
-
-		}
-
-		if ( this.isScene ) {
-
-			if ( this.background ) {
-
-				if ( this.background.isColor ) {
-
-					object.background = this.background.toJSON();
-
-				} else if ( this.background.isTexture ) {
-
-					object.background = this.background.toJSON( meta ).uuid;
-
-				}
-
-			}
-
-			if ( this.environment && this.environment.isTexture ) {
-
-				object.environment = this.environment.toJSON( meta ).uuid;
-
-			}
-
-		} else if ( this.isMesh || this.isLine || this.isPoints ) {
-
-			object.geometry = serialize( meta.geometries, this.geometry );
-
-			const parameters = this.geometry.parameters;
-
-			if ( parameters !== undefined && parameters.shapes !== undefined ) {
-
-				const shapes = parameters.shapes;
-
-				if ( Array.isArray( shapes ) ) {
-
-					for ( let i = 0, l = shapes.length; i < l; i ++ ) {
-
-						const shape = shapes[ i ];
-
-						serialize( meta.shapes, shape );
-
-					}
-
-				} else {
-
-					serialize( meta.shapes, shapes );
-
-				}
-
-			}
-
-		}
-
-		if ( this.isSkinnedMesh ) {
-
-			object.bindMode = this.bindMode;
-			object.bindMatrix = this.bindMatrix.toArray();
-
-			if ( this.skeleton !== undefined ) {
-
-				serialize( meta.skeletons, this.skeleton );
-
-				object.skeleton = this.skeleton.uuid;
-
-			}
-
-		}
-
-		if ( this.material !== undefined ) {
-
-			if ( Array.isArray( this.material ) ) {
-
-				const uuids = [];
-
-				for ( let i = 0, l = this.material.length; i < l; i ++ ) {
-
-					uuids.push( serialize( meta.materials, this.material[ i ] ) );
-
-				}
-
-				object.material = uuids;
-
-			} else {
-
-				object.material = serialize( meta.materials, this.material );
-
-			}
-
-		}
-
-		//
-
-		if ( this.children.length > 0 ) {
-
-			object.children = [];
-
-			for ( let i = 0; i < this.children.length; i ++ ) {
-
-				object.children.push( this.children[ i ].toJSON( meta ).object );
-
-			}
-
-		}
-
-		//
-
-		if ( this.animations.length > 0 ) {
-
-			object.animations = [];
-
-			for ( let i = 0; i < this.animations.length; i ++ ) {
-
-				const animation = this.animations[ i ];
-
-				object.animations.push( serialize( meta.animations, animation ) );
-
-			}
-
-		}
-
-		if ( isRootObject ) {
-
-			const geometries = extractFromCache( meta.geometries );
-			const materials = extractFromCache( meta.materials );
-			const textures = extractFromCache( meta.textures );
-			const images = extractFromCache( meta.images );
-			const shapes = extractFromCache( meta.shapes );
-			const skeletons = extractFromCache( meta.skeletons );
-			const animations = extractFromCache( meta.animations );
-			const nodes = extractFromCache( meta.nodes );
-
-			if ( geometries.length > 0 ) output.geometries = geometries;
-			if ( materials.length > 0 ) output.materials = materials;
-			if ( textures.length > 0 ) output.textures = textures;
-			if ( images.length > 0 ) output.images = images;
-			if ( shapes.length > 0 ) output.shapes = shapes;
-			if ( skeletons.length > 0 ) output.skeletons = skeletons;
-			if ( animations.length > 0 ) output.animations = animations;
-			if ( nodes.length > 0 ) output.nodes = nodes;
-
-		}
-
-		output.object = object;
-
-		return output;
-
-		// extract data from the cache hash
-		// remove metadata on each item
-		// and return as array
-		function extractFromCache( cache ) {
-
-			const values = [];
-			for ( const key in cache ) {
-
-				const data = cache[ key ];
-				delete data.metadata;
-				values.push( data );
-
-			}
-
-			return values;
-
-		}
-
-	}
-
-	clone( recursive ) {
-
-		return new this.constructor().copy( this, recursive );
-
-	}
-
-	copy( source, recursive = true ) {
-
-		this.name = source.name;
-
-		this.up.copy( source.up );
-
-		this.position.copy( source.position );
-		this.rotation.order = source.rotation.order;
-		this.quaternion.copy( source.quaternion );
-		this.scale.copy( source.scale );
-
-		this.matrix.copy( source.matrix );
-		this.matrixWorld.copy( source.matrixWorld );
-
-		this.matrixAutoUpdate = source.matrixAutoUpdate;
-		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
-
-		this.layers.mask = source.layers.mask;
-		this.visible = source.visible;
-
-		this.castShadow = source.castShadow;
-		this.receiveShadow = source.receiveShadow;
-
-		this.frustumCulled = source.frustumCulled;
-		this.renderOrder = source.renderOrder;
-
-		this.userData = JSON.parse( JSON.stringify( source.userData ) );
-
-		if ( recursive === true ) {
-
-			for ( let i = 0; i < source.children.length; i ++ ) {
-
-				const child = source.children[ i ];
-				this.add( child.clone() );
-
-			}
-
-		}
-
-		return this;
-
-	}
+        this.matrix.copy(source.matrix);
+        this.matrixWorld.copy(source.matrixWorld);
+
+        this.matrixAutoUpdate = source.matrixAutoUpdate;
+        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
+
+        this.layers.mask = source.layers.mask;
+        this.visible = source.visible;
+
+        this.castShadow = source.castShadow;
+        this.receiveShadow = source.receiveShadow;
+
+        this.frustumCulled = source.frustumCulled;
+        this.renderOrder = source.renderOrder;
+
+        this.userData = JSON.parse(JSON.stringify(source.userData));
+
+        if (recursive === true) {
+            for (let i = 0; i < source.children.length; i++) {
+                const child = source.children[i];
+                this.add(child.clone());
+            }
+        }
 
+        return this;
+    }
 }
 
-Object3D.DefaultUp = new Vector3( 0, 1, 0 );
+Object3D.DefaultUp = new Vector3(0, 1, 0);
 Object3D.DefaultMatrixAutoUpdate = true;
 
 export { Object3D };